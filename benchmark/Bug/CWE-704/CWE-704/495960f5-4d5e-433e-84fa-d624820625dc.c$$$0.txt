-----label-----
1
-----code-----
void CWE194_Unexpected_Sign_Extension__rand_malloc_32_bad()
{
    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    /* Initialize data */
    data = 0;
    {
        short data = *dataPtr1;
        /* FLAW: Use a random value that could be less than 0 */
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        /* Assume we want to allocate a relatively small buffer */
        if (data < 100)
        {
            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,
             * the conversion will cause malloc() to allocate a very large amount of data or fail */
            char * dataBuffer = (char *)malloc(data);
            if (dataBuffer == NULL) {exit(-1);}
            /* Do something with dataBuffer */
            memset(dataBuffer, 'A', data-1);
            dataBuffer[data-1] = '\0';
            printLine(dataBuffer);
            free(dataBuffer);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
9,10
11,12
12,13
12,14
14,15
14,16
14,17
17,18
18,19
19,20
21,22
22,23
22,24
24,25
24,26
24,27
27,28
28,29
29,30
31,32
32,33
32,34
33,34
36,37
36,38
36,39
37,38
38,39
38,40
40,41
40,42
42,43
43,44
44,45
46,47
47,48
47,49
48,49
50,51
50,52
51,52
51,53
54,55
55,56
57,58
58,59
58,60
59,60
60,61
62,63
64,65
64,66
65,66
66,67
66,68
68,69
68,70
70,71
71,72
72,73
74,75
74,76
75,76
75,77
76,77
79,80
79,81
79,82
79,83
79,84
79,85
80,81
81,82
81,83
83,84
83,85
83,86
86,87
87,88
87,89
88,89
88,90
90,91
92,93
92,94
93,94
95,96
97,98
97,99
98,99
98,100
99,100
101,102
103,104
104,105
105,106
105,107
106,107
108,109
110,111
111,112
111,113
111,114
111,115
112,113
114,115
117,118
117,119
118,119
121,122
122,123
122,124
123,124
123,125
124,125
126,127
126,128
127,128
131,132
132,133
132,134
133,134
135,136
137,138
138,139
138,140
139,140
141,142
-----nextToken-----
2,4,8,10,13,15,16,20,23,25,26,30,34,35,39,41,45,49,52,53,56,61,63,67,69,73,77,78,82,84,85,89,91,94,96,100,102,107,109,113,115,116,119,120,125,128,129,130,134,136,140,142
-----computeFrom-----
32,33
32,34
47,48
47,49
58,59
58,60
75,76
75,77
98,99
98,100
117,118
117,119
122,123
122,124
126,127
126,128
-----guardedBy-----
77,128
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE194_Unexpected_Sign_Extension__rand_malloc_32_bad(){    short data;    short *dataPtr1 = &data;    short *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        short data = *dataPtr1;        /* FLAW: Use a random value that could be less than 0 */        data = (short)RAND32();        *dataPtr1 = data;    }    {        short data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }}
void
CWE194_Unexpected_Sign_Extension__rand_malloc_32_bad()
CWE194_Unexpected_Sign_Extension__rand_malloc_32_bad
{    short data;    short *dataPtr1 = &data;    short *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        short data = *dataPtr1;        /* FLAW: Use a random value that could be less than 0 */        data = (short)RAND32();        *dataPtr1 = data;    }    {        short data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }}
short data;
short data;
short
data
data
short *dataPtr1 = &data;
short *dataPtr1 = &data;
short
*dataPtr1 = &data
*
dataPtr1
= &data
&data
data
data
short *dataPtr2 = &data;
short *dataPtr2 = &data;
short
*dataPtr2 = &data
*
dataPtr2
= &data
&data
data
data
data = 0;
data = 0
data
data
0
{        short data = *dataPtr1;        /* FLAW: Use a random value that could be less than 0 */        data = (short)RAND32();        *dataPtr1 = data;    }
short data = *dataPtr1;
short data = *dataPtr1;
short
data = *dataPtr1
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
data = (short)RAND32();
data = (short)RAND32()
data
data
(short)RAND32()
short
short

RAND32()
RAND32
RAND32
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        short data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }
short data = *dataPtr2;
short data = *dataPtr2;
short
data = *dataPtr2
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }
data < 100
data
data
100
{            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }
char * dataBuffer = (char *)malloc(data);
char * dataBuffer = (char *)malloc(data);
char
* dataBuffer = (char *)malloc(data)
*
dataBuffer
= (char *)malloc(data)
(char *)malloc(data)
char *
char
*
*
malloc(data)
malloc
malloc
data
data
if (dataBuffer == NULL) {exit(-1);}
dataBuffer == NULL
dataBuffer
dataBuffer
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
memset(dataBuffer, 'A', data-1);
memset(dataBuffer, 'A', data-1)
memset
memset
dataBuffer
dataBuffer
'A'
data-1
data
data
1
dataBuffer[data-1] = '\0';
dataBuffer[data-1] = '\0'
dataBuffer[data-1]
dataBuffer
dataBuffer
data-1
data
data
1
'\0'
printLine(dataBuffer);
printLine(dataBuffer)
printLine
printLine
dataBuffer
dataBuffer
free(dataBuffer);
free(dataBuffer)
free
free
dataBuffer
dataBuffer
-----joern-----
(50,2,0)
(58,54,0)
(25,17,0)
(33,21,0)
(51,29,0)
(24,74,0)
(46,61,0)
(41,72,0)
(42,3,0)
(1,75,0)
(35,42,0)
(48,37,0)
(3,42,0)
(28,37,0)
(2,21,0)
(22,45,0)
(69,65,0)
(67,76,0)
(2,50,0)
(47,22,0)
(72,44,0)
(14,36,0)
(38,44,0)
(61,46,0)
(7,4,0)
(22,29,0)
(11,21,0)
(26,30,0)
(16,68,0)
(64,6,0)
(42,52,0)
(45,4,0)
(75,45,0)
(65,35,0)
(5,44,0)
(37,48,0)
(34,6,0)
(56,15,0)
(29,51,0)
(53,67,0)
(39,2,0)
(35,77,0)
(29,44,0)
(48,44,0)
(63,74,0)
(76,67,0)
(27,33,0)
(29,22,0)
(48,6,0)
(13,61,0)
(12,15,0)
(4,45,0)
(72,75,0)
(32,46,0)
(71,35,0)
(40,21,0)
(42,35,0)
(4,46,0)
(44,29,0)
(36,6,0)
(52,42,0)
(55,37,0)
(76,20,0)
(74,44,0)
(59,77,0)
(77,21,0)
(66,50,0)
(65,77,0)
(17,30,0)
(57,33,0)
(54,65,0)
(10,68,0)
(43,23,0)
(45,15,0)
(17,2,0)
(54,2,0)
(31,21,0)
(23,6,0)
(18,38,0)
(44,6,0)
(30,17,0)
(75,72,0)
(38,6,0)
(72,23,0)
(30,77,0)
(46,21,0)
(8,48,0)
(36,44,0)
(15,21,0)
(19,48,0)
(0,75,0)
(68,45,0)
(70,45,0)
(37,45,0)
(37,55,1)
(29,51,1)
(27,46,1)
(50,66,1)
(4,7,1)
(54,58,1)
(5,68,1)
(63,24,1)
(2,50,1)
(23,43,1)
(53,74,1)
(28,8,1)
(66,39,1)
(42,52,1)
(68,16,1)
(42,3,1)
(29,22,1)
(19,76,1)
(47,5,1)
(46,61,1)
(65,35,1)
(44,29,1)
(10,45,1)
(13,32,1)
(19,74,1)
(9,36,1)
(65,69,1)
(48,44,1)
(26,33,1)
(57,27,1)
(38,44,1)
(74,63,1)
(38,18,1)
(70,65,1)
(0,41,1)
(75,45,1)
(36,44,1)
(24,44,1)
(22,45,1)
(25,26,1)
(76,67,1)
(4,46,1)
(58,35,1)
(74,44,1)
(3,71,1)
(30,17,1)
(33,57,1)
(48,37,1)
(61,13,1)
(37,45,1)
(69,54,1)
(35,42,1)
(18,23,1)
(55,28,1)
(68,45,1)
(72,44,1)
(1,0,1)
(7,70,1)
(72,75,1)
(41,48,1)
(22,47,1)
(45,4,1)
(16,10,1)
(14,38,1)
(36,14,1)
(17,25,1)
(43,72,1)
(67,53,1)
(75,1,1)
(32,2,1)
(8,19,1)
(17,2,1)
(71,30,1)
(54,2,1)
(9,68,1)
(36,68,2)
(5,68,2)
(74,68,2)
(55,68,2)
(45,4,2)
(76,67,2)
(29,22,2)
(2,50,2)
(22,68,2)
(36,44,2)
(43,68,2)
(35,42,2)
(65,35,2)
(44,68,2)
(14,68,2)
(1,68,2)
(53,74,2)
(17,2,2)
(28,68,2)
(48,37,2)
(41,68,2)
(63,68,2)
(46,61,2)
(22,45,2)
(72,44,2)
(44,29,2)
(29,68,2)
(68,45,2)
(38,68,2)
(42,52,2)
(75,68,2)
(24,68,2)
(75,45,2)
(4,46,2)
(18,68,2)
(47,68,2)
(42,3,2)
(37,68,2)
(72,75,2)
(8,68,2)
(37,45,2)
(0,68,2)
(72,68,2)
(23,68,2)
(76,74,2)
(48,68,2)
(30,17,2)
(38,44,2)
(67,74,2)
(74,44,2)
(48,44,2)
(54,2,2)
(19,68,2)
(29,51,2)
-----------------------------------
(0,data)
(1,1)
(2,*dataPtr1 = &data)
(3,RAND32()
(4,*dataPtr2)
(5,dataBuffer)
(6,)
(7,dataPtr2)
(8,'A')
(9,RET)
(10,data)
(11,dataPtr1)
(12,if (data < 100)
(13,data)
(14,dataBuffer)
(15,)
(16,100)
(17,*dataPtr1)
(18,dataBuffer)
(19,dataBuffer)
(20,)
(21,)
(22,malloc(data)
(23,dataBuffer[data-1] = \'\\\\0\')
(24,dataBuffer)
(25,dataPtr1)
(26,data)
(27,data)
(28,data)
(29,(char *)
(30,data = *dataPtr1)
(31,data)
(32,dataPtr2)
(33,data = 0)
(34,dataBuffer)
(35,data = (short)
(36,free(dataBuffer)
(37,data-1)
(38,printLine(dataBuffer)
(39,dataPtr1)
(40,dataPtr2)
(41,dataBuffer)
(42,(short)
(43,'\\\\0')
(44,* dataBuffer = (char *)
(45,data = *dataPtr2)
(46,*dataPtr2 = &data)
(47,data)
(48,memset(dataBuffer, 'A', data-1)
(49,memset(dataBuffer, \'A\', data-1)
(50,&data)
(51,char *)
(52,short)
(53,1)
(54,*dataPtr1)
(55,1)
(56,data)
(57,0)
(58,dataPtr1)
(59,data)
(60,dataBuffer[data-1] = '\\\\0')
(61,&data)
(62,\'\\\\0\')
(63,NULL)
(64,if (dataBuffer == NULL)
(65,*dataPtr1 = data)
(66,data)
(67,-1)
(68,data < 100)
(69,data)
(70,data)
(71,data)
(72,dataBuffer[data-1])
(73,\'A\')
(74,dataBuffer == NULL)
(75,data-1)
(76,exit(-1)
(77,)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^