-----label-----
1
-----code-----
void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_bad()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    /* Initialize data */
    data = -1;
    {
        int data = *dataPtr1;
        /* POTENTIAL FLAW: Set data to a random value */
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        /* Assume we want to allocate a relatively small buffer */
        if (data < 100)
        {
            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,
             * the conversion will cause malloc() to allocate a very large amount of data or fail */
            char * dataBuffer = (char *)malloc(data);
            if (dataBuffer == NULL) {exit(-1);}
            /* Do something with dataBuffer */
            memset(dataBuffer, 'A', data-1);
            dataBuffer[data-1] = '\0';
            printLine(dataBuffer);
            free(dataBuffer);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
9,10
11,12
12,13
12,14
14,15
14,16
14,17
17,18
18,19
19,20
21,22
22,23
22,24
24,25
24,26
24,27
27,28
28,29
29,30
31,32
32,33
32,34
33,34
35,36
37,38
37,39
37,40
38,39
39,40
39,41
41,42
41,43
43,44
44,45
45,46
47,48
48,49
48,50
49,50
51,52
52,53
54,55
55,56
55,57
56,57
57,58
59,60
61,62
61,63
62,63
63,64
63,65
65,66
65,67
67,68
68,69
69,70
71,72
71,73
72,73
72,74
73,74
76,77
76,78
76,79
76,80
76,81
76,82
77,78
78,79
78,80
80,81
80,82
80,83
83,84
84,85
84,86
85,86
85,87
87,88
89,90
89,91
90,91
92,93
94,95
94,96
95,96
95,97
96,97
98,99
100,101
101,102
102,103
102,104
103,104
105,106
107,108
108,109
108,110
108,111
108,112
109,110
111,112
114,115
114,116
115,116
118,119
119,120
119,121
120,121
120,122
121,122
123,124
123,125
124,125
128,129
129,130
129,131
130,131
132,133
134,135
135,136
135,137
136,137
138,139
-----nextToken-----
2,4,8,10,13,15,16,20,23,25,26,30,34,36,40,42,46,50,53,58,60,64,66,70,74,75,79,81,82,86,88,91,93,97,99,104,106,110,112,113,116,117,122,125,126,127,131,133,137,139
-----computeFrom-----
32,33
32,34
48,49
48,50
55,56
55,57
72,73
72,74
95,96
95,97
114,115
114,116
119,120
119,121
123,124
123,125
-----guardedBy-----
74,125
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_bad(){    int data;    int *dataPtr1 = &data;    int *dataPtr2 = &data;    /* Initialize data */    data = -1;    {        int data = *dataPtr1;        /* POTENTIAL FLAW: Set data to a random value */        data = RAND32();        *dataPtr1 = data;    }    {        int data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }}
void
CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_bad()
CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_bad
{    int data;    int *dataPtr1 = &data;    int *dataPtr2 = &data;    /* Initialize data */    data = -1;    {        int data = *dataPtr1;        /* POTENTIAL FLAW: Set data to a random value */        data = RAND32();        *dataPtr1 = data;    }    {        int data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }}
int data;
int data;
int
data
data
int *dataPtr1 = &data;
int *dataPtr1 = &data;
int
*dataPtr1 = &data
*
dataPtr1
= &data
&data
data
data
int *dataPtr2 = &data;
int *dataPtr2 = &data;
int
*dataPtr2 = &data
*
dataPtr2
= &data
&data
data
data
data = -1;
data = -1
data
data
-1
1
{        int data = *dataPtr1;        /* POTENTIAL FLAW: Set data to a random value */        data = RAND32();        *dataPtr1 = data;    }
int data = *dataPtr1;
int data = *dataPtr1;
int
data = *dataPtr1
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
data = RAND32();
data = RAND32()
data
data
RAND32()
RAND32
RAND32
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        int data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }
int data = *dataPtr2;
int data = *dataPtr2;
int
data = *dataPtr2
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }
data < 100
data
data
100
{            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }
char * dataBuffer = (char *)malloc(data);
char * dataBuffer = (char *)malloc(data);
char
* dataBuffer = (char *)malloc(data)
*
dataBuffer
= (char *)malloc(data)
(char *)malloc(data)
char *
char
*
*
malloc(data)
malloc
malloc
data
data
if (dataBuffer == NULL) {exit(-1);}
dataBuffer == NULL
dataBuffer
dataBuffer
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
memset(dataBuffer, 'A', data-1);
memset(dataBuffer, 'A', data-1)
memset
memset
dataBuffer
dataBuffer
'A'
data-1
data
data
1
dataBuffer[data-1] = '\0';
dataBuffer[data-1] = '\0'
dataBuffer[data-1]
dataBuffer
dataBuffer
data-1
data
data
1
'\0'
printLine(dataBuffer);
printLine(dataBuffer)
printLine
printLine
dataBuffer
dataBuffer
free(dataBuffer);
free(dataBuffer)
free
free
dataBuffer
dataBuffer
-----joern-----
(23,0,0)
(14,13,0)
(15,24,0)
(23,25,0)
(58,28,0)
(1,36,0)
(7,0,0)
(41,65,0)
(73,2,0)
(8,0,0)
(72,5,0)
(33,24,0)
(43,66,0)
(39,0,0)
(38,41,0)
(39,28,0)
(64,41,0)
(31,5,0)
(63,18,0)
(42,59,0)
(36,54,0)
(59,54,0)
(19,73,0)
(36,45,0)
(69,65,0)
(28,39,0)
(65,13,0)
(47,39,0)
(25,65,0)
(0,74,0)
(13,65,0)
(56,74,0)
(53,8,0)
(4,66,0)
(20,8,0)
(49,34,0)
(18,74,0)
(68,34,0)
(56,0,0)
(6,21,0)
(24,33,0)
(0,23,0)
(16,32,0)
(25,23,0)
(23,55,0)
(21,35,0)
(31,62,0)
(59,36,0)
(65,44,0)
(27,34,0)
(66,4,0)
(75,73,0)
(5,31,0)
(44,2,0)
(18,0,0)
(13,35,0)
(29,44,0)
(35,2,0)
(32,59,0)
(67,25,0)
(60,33,0)
(9,50,0)
(26,68,0)
(50,74,0)
(35,21,0)
(61,2,0)
(4,24,0)
(34,0,0)
(51,74,0)
(34,74,0)
(45,36,0)
(24,2,0)
(55,23,0)
(34,68,0)
(32,24,0)
(17,54,0)
(46,2,0)
(39,50,0)
(11,56,0)
(54,2,0)
(48,2,0)
(28,65,0)
(22,68,0)
(68,65,0)
(30,4,0)
(3,35,0)
(12,19,0)
(76,28,0)
(37,44,0)
(66,54,0)
(73,19,0)
(10,74,0)
(26,49,1)
(40,41,1)
(4,30,1)
(50,9,1)
(39,0,1)
(66,4,1)
(72,8,1)
(38,65,1)
(40,18,1)
(36,45,1)
(13,35,1)
(41,65,1)
(0,23,1)
(33,60,1)
(23,25,1)
(34,0,1)
(69,59,1)
(68,22,1)
(16,36,1)
(47,34,1)
(39,28,1)
(76,58,1)
(75,35,1)
(64,38,1)
(1,66,1)
(65,13,1)
(42,32,1)
(59,42,1)
(53,0,1)
(5,72,1)
(18,0,1)
(24,33,1)
(22,26,1)
(63,56,1)
(32,24,1)
(43,73,1)
(41,64,1)
(13,14,1)
(27,31,1)
(23,55,1)
(3,24,1)
(34,68,1)
(12,75,1)
(11,50,1)
(20,53,1)
(59,36,1)
(31,5,1)
(25,65,1)
(27,8,1)
(4,24,1)
(35,21,1)
(28,65,1)
(25,67,1)
(73,19,1)
(7,41,1)
(14,69,1)
(32,16,1)
(9,39,1)
(19,12,1)
(8,20,1)
(21,6,1)
(6,3,1)
(56,11,1)
(56,0,1)
(60,15,1)
(8,0,1)
(30,43,1)
(68,65,1)
(45,1,1)
(18,63,1)
(49,27,1)
(58,47,1)
(67,7,1)
(28,76,1)
(25,41,2)
(4,24,2)
(59,36,2)
(34,68,2)
(39,0,2)
(24,33,2)
(76,41,2)
(20,41,2)
(68,65,2)
(49,41,2)
(23,41,2)
(23,55,2)
(31,8,2)
(73,19,2)
(58,41,2)
(9,41,2)
(50,41,2)
(0,41,2)
(32,24,2)
(39,28,2)
(41,65,2)
(39,41,2)
(47,41,2)
(36,45,2)
(56,41,2)
(63,41,2)
(8,41,2)
(26,41,2)
(34,0,2)
(53,41,2)
(11,41,2)
(13,35,2)
(7,41,2)
(8,0,2)
(18,0,2)
(27,41,2)
(56,0,2)
(72,8,2)
(5,8,2)
(35,21,2)
(68,41,2)
(25,65,2)
(34,41,2)
(67,41,2)
(28,65,2)
(28,41,2)
(0,23,2)
(66,4,2)
(65,13,2)
(23,25,2)
(31,5,2)
(18,41,2)
(22,41,2)
-----------------------------------
(0,* dataBuffer = (char *)
(1,data)
(2,)
(3,dataPtr2)
(4,*dataPtr1)
(5,-1)
(6,data)
(7,dataBuffer)
(8,dataBuffer == NULL)
(9,'\\\\0')
(10,dataBuffer)
(11,dataBuffer)
(12,1)
(13,*dataPtr2)
(14,dataPtr2)
(15,dataPtr1)
(16,dataPtr1)
(17,data)
(18,free(dataBuffer)
(19,-1)
(20,NULL)
(21,&data)
(22,1)
(23,(char *)
(24,*dataPtr1 = &data)
(25,malloc(data)
(26,data)
(27,dataBuffer)
(28,data-1)
(29,data)
(30,dataPtr1)
(31,exit(-1)
(32,*dataPtr1)
(33,&data)
(34,memset(dataBuffer, 'A', data-1)
(35,*dataPtr2 = &data)
(36,data = RAND32()
(37,if (data < 100)
(38,data)
(39,dataBuffer[data-1])
(40,RET)
(41,data < 100)
(42,data)
(43,data)
(44,)
(45,RAND32()
(46,data)
(47,dataBuffer)
(48,dataPtr1)
(49,\'A\')
(50,dataBuffer[data-1] = '\\\\0')
(51,if (dataBuffer == NULL)
(52,memset(dataBuffer, \'A\', data-1)
(53,dataBuffer)
(54,)
(55,char *)
(56,printLine(dataBuffer)
(57,'A')
(58,data)
(59,*dataPtr1 = data)
(60,data)
(61,dataPtr2)
(62,)
(63,dataBuffer)
(64,100)
(65,data = *dataPtr2)
(66,data = *dataPtr1)
(67,data)
(68,data-1)
(69,data)
(70,dataBuffer[data-1] = \'\\\\0\')
(71,\'\\\\0\')
(72,1)
(73,data = -1)
(74,)
(75,data)
(76,1)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^