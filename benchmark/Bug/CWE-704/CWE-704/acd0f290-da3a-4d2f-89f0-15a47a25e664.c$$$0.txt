-----label-----
1
-----code-----
void CWE194_Unexpected_Sign_Extension__fscanf_malloc_32_bad()
{
    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    /* Initialize data */
    data = 0;
    {
        short data = *dataPtr1;
        /* FLAW: Use a value input from the console using fscanf() */
        fscanf (stdin, "%hd", &data);
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        /* Assume we want to allocate a relatively small buffer */
        if (data < 100)
        {
            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,
             * the conversion will cause malloc() to allocate a very large amount of data or fail */
            char * dataBuffer = (char *)malloc(data);
            if (dataBuffer == NULL) {exit(-1);}
            /* Do something with dataBuffer */
            memset(dataBuffer, 'A', data-1);
            dataBuffer[data-1] = '\0';
            printLine(dataBuffer);
            free(dataBuffer);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
9,10
11,12
12,13
12,14
14,15
14,16
14,17
17,18
18,19
19,20
21,22
22,23
22,24
24,25
24,26
24,27
27,28
28,29
29,30
31,32
32,33
32,34
33,34
36,37
36,38
36,39
37,38
38,39
38,40
40,41
40,42
42,43
43,44
44,45
46,47
47,48
47,49
47,50
47,51
48,49
50,51
53,54
54,55
56,57
57,58
57,59
58,59
59,60
61,62
63,64
63,65
64,65
65,66
65,67
67,68
67,69
69,70
70,71
71,72
73,74
73,75
74,75
74,76
75,76
78,79
78,80
78,81
78,82
78,83
78,84
79,80
80,81
80,82
82,83
82,84
82,85
85,86
86,87
86,88
87,88
87,89
89,90
91,92
91,93
92,93
94,95
96,97
96,98
97,98
97,99
98,99
100,101
102,103
103,104
104,105
104,106
105,106
107,108
109,110
110,111
110,112
110,113
110,114
111,112
113,114
116,117
116,118
117,118
120,121
121,122
121,123
122,123
122,124
123,124
125,126
125,127
126,127
130,131
131,132
131,133
132,133
134,135
136,137
137,138
137,139
138,139
140,141
-----nextToken-----
2,4,8,10,13,15,16,20,23,25,26,30,34,35,39,41,45,49,51,52,55,60,62,66,68,72,76,77,81,83,84,88,90,93,95,99,101,106,108,112,114,115,118,119,124,127,128,129,133,135,139,141
-----computeFrom-----
32,33
32,34
57,58
57,59
74,75
74,76
97,98
97,99
116,117
116,118
121,122
121,123
125,126
125,127
-----guardedBy-----
76,127
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE194_Unexpected_Sign_Extension__fscanf_malloc_32_bad(){    short data;    short *dataPtr1 = &data;    short *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        short data = *dataPtr1;        /* FLAW: Use a value input from the console using fscanf() */        fscanf (stdin, "%hd", &data);        *dataPtr1 = data;    }    {        short data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }}
void
CWE194_Unexpected_Sign_Extension__fscanf_malloc_32_bad()
CWE194_Unexpected_Sign_Extension__fscanf_malloc_32_bad
{    short data;    short *dataPtr1 = &data;    short *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        short data = *dataPtr1;        /* FLAW: Use a value input from the console using fscanf() */        fscanf (stdin, "%hd", &data);        *dataPtr1 = data;    }    {        short data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }}
short data;
short data;
short
data
data
short *dataPtr1 = &data;
short *dataPtr1 = &data;
short
*dataPtr1 = &data
*
dataPtr1
= &data
&data
data
data
short *dataPtr2 = &data;
short *dataPtr2 = &data;
short
*dataPtr2 = &data
*
dataPtr2
= &data
&data
data
data
data = 0;
data = 0
data
data
0
{        short data = *dataPtr1;        /* FLAW: Use a value input from the console using fscanf() */        fscanf (stdin, "%hd", &data);        *dataPtr1 = data;    }
short data = *dataPtr1;
short data = *dataPtr1;
short
data = *dataPtr1
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
fscanf (stdin, "%hd", &data);
fscanf (stdin, "%hd", &data)
fscanf
fscanf
stdin
stdin
"%hd"
&data
data
data
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        short data = *dataPtr2;        /* Assume we want to allocate a relatively small buffer */        if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }    }
short data = *dataPtr2;
short data = *dataPtr2;
short
data = *dataPtr2
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
if (data < 100)        {            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }
data < 100
data
data
100
{            /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,             * the conversion will cause malloc() to allocate a very large amount of data or fail */            char * dataBuffer = (char *)malloc(data);            if (dataBuffer == NULL) {exit(-1);}            /* Do something with dataBuffer */            memset(dataBuffer, 'A', data-1);            dataBuffer[data-1] = '\0';            printLine(dataBuffer);            free(dataBuffer);        }
char * dataBuffer = (char *)malloc(data);
char * dataBuffer = (char *)malloc(data);
char
* dataBuffer = (char *)malloc(data)
*
dataBuffer
= (char *)malloc(data)
(char *)malloc(data)
char *
char
*
*
malloc(data)
malloc
malloc
data
data
if (dataBuffer == NULL) {exit(-1);}
dataBuffer == NULL
dataBuffer
dataBuffer
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
memset(dataBuffer, 'A', data-1);
memset(dataBuffer, 'A', data-1)
memset
memset
dataBuffer
dataBuffer
'A'
data-1
data
data
1
dataBuffer[data-1] = '\0';
dataBuffer[data-1] = '\0'
dataBuffer[data-1]
dataBuffer
dataBuffer
data-1
data
data
1
'\0'
printLine(dataBuffer);
printLine(dataBuffer)
printLine
printLine
dataBuffer
dataBuffer
free(dataBuffer);
free(dataBuffer)
free
free
dataBuffer
dataBuffer
-----joern-----
(20,30,0)
(46,59,0)
(60,62,0)
(38,37,0)
(26,18,0)
(33,47,0)
(3,15,0)
(15,18,0)
(40,26,0)
(72,24,0)
(47,62,0)
(29,41,0)
(66,27,0)
(57,9,0)
(31,19,0)
(39,70,0)
(54,9,0)
(51,41,0)
(15,3,0)
(63,40,0)
(68,3,0)
(14,13,0)
(42,71,0)
(30,41,0)
(23,5,0)
(11,15,0)
(65,52,0)
(24,47,0)
(44,53,0)
(45,26,0)
(2,41,0)
(0,39,0)
(22,52,0)
(50,47,0)
(35,27,0)
(4,50,0)
(32,69,0)
(36,29,0)
(19,29,0)
(1,22,0)
(71,28,0)
(34,58,0)
(10,50,0)
(24,53,0)
(13,14,0)
(29,39,0)
(28,71,0)
(8,37,0)
(67,14,0)
(26,40,0)
(9,41,0)
(8,28,0)
(53,58,0)
(52,29,0)
(47,24,0)
(70,39,0)
(52,51,0)
(13,49,0)
(0,47,0)
(39,0,0)
(21,27,0)
(39,29,0)
(40,15,0)
(17,28,0)
(37,15,0)
(19,41,0)
(69,27,0)
(73,69,0)
(55,59,0)
(3,28,0)
(28,27,0)
(7,22,0)
(59,29,0)
(64,0,0)
(5,47,0)
(30,29,0)
(6,8,0)
(62,27,0)
(48,26,0)
(16,41,0)
(22,47,0)
(53,27,0)
(5,9,0)
(37,18,0)
(61,18,0)
(25,5,0)
(12,62,0)
(9,29,0)
(58,53,0)
(52,22,0)
(56,51,0)
(9,5,0)
(18,27,0)
(37,15,1)
(7,1,1)
(0,47,1)
(30,20,1)
(48,15,1)
(65,9,1)
(39,70,1)
(53,58,1)
(59,46,1)
(40,63,1)
(44,28,1)
(19,31,1)
(52,29,1)
(30,29,1)
(14,67,1)
(31,30,1)
(5,47,1)
(39,0,1)
(9,29,1)
(26,40,1)
(23,57,1)
(24,53,1)
(34,44,1)
(69,32,1)
(24,72,1)
(38,8,1)
(4,47,1)
(42,17,1)
(10,4,1)
(67,59,1)
(54,13,1)
(25,23,1)
(33,37,1)
(57,54,1)
(40,15,1)
(43,50,1)
(63,45,1)
(51,56,1)
(3,68,1)
(5,25,1)
(9,5,1)
(0,64,1)
(59,29,1)
(22,47,1)
(36,50,1)
(55,29,1)
(32,73,1)
(58,34,1)
(54,59,1)
(3,28,1)
(64,36,1)
(13,14,1)
(43,19,1)
(22,7,1)
(71,42,1)
(73,53,1)
(8,6,1)
(56,52,1)
(20,51,1)
(8,28,1)
(6,26,1)
(72,33,1)
(29,39,1)
(47,24,1)
(37,38,1)
(45,48,1)
(15,3,1)
(1,65,1)
(28,71,1)
(50,47,1)
(11,69,1)
(52,22,1)
(46,55,1)
(19,29,1)
(68,11,1)
(50,10,1)
(20,50,2)
(52,29,2)
(19,29,2)
(65,50,2)
(23,50,2)
(8,28,2)
(64,50,2)
(9,5,2)
(19,50,2)
(31,50,2)
(52,50,2)
(9,29,2)
(37,15,2)
(14,59,2)
(59,50,2)
(30,50,2)
(25,50,2)
(3,28,2)
(24,53,2)
(5,50,2)
(67,59,2)
(39,0,2)
(28,71,2)
(52,22,2)
(55,50,2)
(13,14,2)
(53,58,2)
(36,50,2)
(9,50,2)
(46,50,2)
(5,47,2)
(54,50,2)
(29,39,2)
(0,47,2)
(22,50,2)
(0,50,2)
(39,50,2)
(22,47,2)
(29,50,2)
(13,59,2)
(39,70,2)
(1,50,2)
(30,29,2)
(50,47,2)
(47,24,2)
(51,50,2)
(56,50,2)
(26,40,2)
(40,15,2)
(57,50,2)
(15,3,2)
(7,50,2)
(59,29,2)
-----------------------------------
(0,malloc(data)
(1,data)
(2,if (dataBuffer == NULL)
(3,*dataPtr1)
(4,data)
(5,data-1)
(6,dataPtr1)
(7,1)
(8,*dataPtr1)
(9,memset(dataBuffer, \\\'A\\\', data-1)
(10,100)
(11,data)
(12,data)
(13,exit(-1)
(14,-1)
(15,data = *dataPtr1)
(16,dataBuffer)
(17,dataPtr1)
(18,)
(19,free(dataBuffer)
(20,dataBuffer)
(21,dataPtr2)
(22,data-1)
(23,data)
(24,*dataPtr2)
(25,1)
(26,fscanf (stdin, "%hd", &data)
(27,)
(28,*dataPtr1 = &data)
(29,* dataBuffer = (char *)
(30,printLine(dataBuffer)
(31,dataBuffer)
(32,0)
(33,data)
(34,data)
(35,dataPtr1)
(36,dataBuffer)
(37,*dataPtr1 = data)
(38,data)
(39,(char *)
(40,&data)
(41,)
(42,data)
(43,RET)
(44,dataPtr2)
(45,"%hd")
(46,NULL)
(47,data = *dataPtr2)
(48,stdin)
(49,)
(50,data < 100)
(51,dataBuffer[data-1] = \\\'\\\\0\\\')
(52,dataBuffer[data-1])
(53,*dataPtr2 = &data)
(54,dataBuffer)
(55,dataBuffer)
(56,\\\'\\\\0\\\')
(57,\\\'A\\\')
(58,&data)
(59,dataBuffer == NULL)
(60,if (data < 100)
(61,data)
(62,)
(63,data)
(64,data)
(65,dataBuffer)
(66,data)
(67,1)
(68,dataPtr1)
(69,data = 0)
(70,char *)
(71,&data)
(72,dataPtr2)
(73,data)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^