-----label-----
1
-----code-----
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_12_bad()
{
    size_t data;
    /* Initialize data */
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = "";
            /* POTENTIAL FLAW: Read data from the console using fgets() */
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                /* Convert to unsigned int */
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine("fgets() failed.");
            }
        }
    }
    else
    {
        /* FIX: Use a relatively small number for memory allocation */
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            wchar_t * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the wcscpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > wcslen(HELLO_STRING))
            {
                myString = (wchar_t *)malloc(data*sizeof(wchar_t));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                wcscpy(myString, HELLO_STRING);
                printWLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string");
            }
        }
    }
    else
    {
        {
            wchar_t * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the wcscpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > wcslen(HELLO_STRING) && data < 100)
            {
                myString = (wchar_t *)malloc(data*sizeof(wchar_t));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                wcscpy(myString, HELLO_STRING);
                printWLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string or too large");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
17,18
17,19
17,20
18,19
19,20
21,22
22,23
22,24
23,24
24,25
24,26
26,27
26,28
26,29
28,29
29,30
31,32
33,34
33,35
33,36
34,35
34,36
35,36
35,37
35,38
35,39
36,37
38,39
40,41
42,43
44,45
46,47
47,48
48,49
48,50
49,50
51,52
51,53
51,54
51,55
52,53
54,55
56,57
59,60
60,61
61,62
61,63
62,63
65,66
66,67
67,68
67,69
68,69
71,72
71,73
71,74
72,73
73,74
75,76
76,77
76,78
77,78
78,79
78,80
80,81
80,82
83,84
83,85
83,86
84,85
84,86
85,86
87,88
87,89
88,89
90,91
92,93
92,94
92,95
92,96
92,97
93,94
94,95
94,96
95,96
97,98
97,99
98,99
98,100
100,101
102,103
102,104
103,104
105,106
105,107
106,107
108,109
109,110
109,111
112,113
112,114
113,114
113,115
114,115
116,117
118,119
119,120
120,121
120,122
121,122
123,124
125,126
126,127
126,128
126,129
127,128
129,130
131,132
133,134
134,135
134,136
135,136
137,138
139,140
140,141
140,142
141,142
143,144
145,146
146,147
147,148
147,149
148,149
151,152
152,153
152,154
153,154
154,155
154,156
156,157
156,158
159,160
159,161
159,162
160,161
160,162
161,162
161,163
162,163
164,165
164,166
165,166
167,168
169,170
169,171
170,171
173,174
173,175
173,176
173,177
173,178
174,175
175,176
175,177
176,177
178,179
178,180
179,180
179,181
181,182
183,184
183,185
184,185
186,187
186,188
187,188
189,190
190,191
190,192
193,194
193,195
194,195
194,196
195,196
197,198
199,200
200,201
201,202
201,203
202,203
204,205
206,207
207,208
207,209
207,210
208,209
210,211
212,213
214,215
215,216
215,217
216,217
218,219
220,221
221,222
221,223
222,223
224,225
226,227
227,228
228,229
228,230
229,230
-----nextToken-----
2,4,9,11,15,16,20,25,27,30,32,37,39,41,43,45,50,53,55,57,58,63,64,69,70,74,79,81,82,86,89,91,96,99,101,104,107,110,111,115,117,122,124,128,130,132,136,138,142,144,149,150,155,157,158,163,166,168,171,172,177,180,182,185,188,191,192,196,198,203,205,209,211,213,217,219,223,225,230,231
-----computeFrom-----
13,14
13,15
34,35
34,36
48,49
48,50
67,68
67,69
84,85
84,86
94,95
94,96
105,106
105,107
113,114
113,115
160,161
160,162
161,162
161,163
169,170
169,171
175,176
175,177
186,187
186,188
194,195
194,196
-----guardedBy-----
39,55
45,57
91,132
86,107
168,213
171,188
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_12_bad(){    size_t data;    /* Initialize data */    data = 0;    if(globalReturnsTrueOrFalse())    {        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    if(globalReturnsTrueOrFalse())    {        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
void
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_12_bad()
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_12_bad
{    size_t data;    /* Initialize data */    data = 0;    if(globalReturnsTrueOrFalse())    {        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    if(globalReturnsTrueOrFalse())    {        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
data = 0;
data = 0
data
data
0
if(globalReturnsTrueOrFalse())    {        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }    }
{            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char
inputBuffer[CHAR_ARRAY_SIZE] = ""
inputBuffer
[CHAR_ARRAY_SIZE]
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
= ""
""
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
fgets
fgets
inputBuffer
inputBuffer
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
stdin
stdin
NULL
NULL
{                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }
data = strtoul(inputBuffer, NULL, 0);
data = strtoul(inputBuffer, NULL, 0)
data
data
strtoul(inputBuffer, NULL, 0)
strtoul
strtoul
inputBuffer
inputBuffer
NULL
NULL
0
{                printLine("fgets() failed.");            }
printLine("fgets() failed.");
printLine("fgets() failed.")
printLine
printLine
"fgets() failed."
{        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
data = 20;
data = 20
data
data
20
if(globalReturnsTrueOrFalse())    {        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }
{            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
{                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string");            }
printLine("Input is less than the length of the source string");
printLine("Input is less than the length of the source string")
printLine
printLine
"Input is less than the length of the source string"
{        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
{            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }
data > wcslen(HELLO_STRING) && data < 100
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string or too large");            }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
-----joern-----
(110,105,0)
(17,106,0)
(83,6,0)
(80,23,0)
(103,78,0)
(14,56,0)
(48,17,0)
(97,30,0)
(60,8,0)
(97,108,0)
(27,61,0)
(30,97,0)
(56,53,0)
(47,76,0)
(46,39,0)
(8,1,0)
(78,93,0)
(95,37,0)
(93,78,0)
(78,103,0)
(104,93,0)
(24,14,0)
(12,110,0)
(87,49,0)
(102,61,0)
(29,89,0)
(11,68,0)
(78,108,0)
(94,32,0)
(41,77,0)
(25,44,0)
(72,85,0)
(28,30,0)
(44,67,0)
(93,104,0)
(81,79,0)
(4,6,0)
(40,44,0)
(58,67,0)
(23,26,0)
(62,37,0)
(75,35,0)
(108,77,0)
(97,72,0)
(34,63,0)
(71,108,0)
(66,88,0)
(9,6,0)
(4,104,0)
(10,94,0)
(70,75,0)
(35,68,0)
(56,91,0)
(14,25,0)
(84,82,0)
(104,4,0)
(15,75,0)
(45,6,0)
(67,44,0)
(73,53,0)
(82,4,0)
(66,89,0)
(68,5,0)
(49,27,0)
(26,69,0)
(42,63,0)
(33,35,0)
(18,72,0)
(44,56,0)
(37,108,0)
(76,27,0)
(36,50,0)
(14,108,0)
(44,25,0)
(59,102,0)
(44,108,0)
(9,4,0)
(51,9,0)
(53,35,0)
(97,56,0)
(31,14,0)
(92,104,0)
(8,27,0)
(100,46,0)
(64,97,0)
(16,75,0)
(104,92,0)
(112,53,0)
(8,60,0)
(78,56,0)
(7,103,0)
(19,108,0)
(83,4,0)
(111,62,0)
(65,61,0)
(54,35,0)
(86,27,0)
(90,75,0)
(97,1,0)
(14,72,0)
(52,56,0)
(101,77,0)
(0,78,0)
(38,72,0)
(79,55,0)
(75,15,0)
(96,17,0)
(1,8,0)
(25,14,0)
(50,61,0)
(21,68,0)
(107,77,0)
(26,23,0)
(37,72,0)
(109,53,0)
(89,66,0)
(53,56,0)
(98,82,0)
(82,6,0)
(63,4,0)
(13,15,0)
(1,97,0)
(49,61,0)
(43,4,0)
(27,8,0)
(2,76,0)
(50,27,0)
(20,49,0)
(74,83,0)
(44,72,0)
(3,110,0)
(102,27,0)
(78,72,0)
(37,62,0)
(37,56,0)
(78,72,1)
(81,25,1)
(78,103,1)
(22,94,1)
(102,59,1)
(73,112,1)
(25,44,1)
(63,4,1)
(82,4,1)
(62,111,1)
(33,54,1)
(14,31,1)
(36,102,1)
(112,109,1)
(52,15,1)
(34,4,1)
(30,28,1)
(44,56,1)
(28,64,1)
(37,56,1)
(42,34,1)
(44,108,1)
(27,8,1)
(31,24,1)
(53,35,1)
(111,95,1)
(56,53,1)
(9,4,1)
(2,27,1)
(95,22,1)
(94,10,1)
(72,38,1)
(35,33,1)
(4,104,1)
(100,37,1)
(97,30,1)
(37,72,1)
(7,0,1)
(26,23,1)
(87,76,1)
(97,72,1)
(23,80,1)
(104,93,1)
(57,50,1)
(83,74,1)
(46,100,1)
(49,27,1)
(37,62,1)
(97,108,1)
(51,82,1)
(50,36,1)
(75,16,1)
(103,7,1)
(80,76,1)
(83,4,1)
(40,22,1)
(13,75,1)
(84,66,1)
(108,71,1)
(64,86,1)
(15,13,1)
(79,81,1)
(70,35,1)
(87,26,1)
(58,40,1)
(49,20,1)
(97,56,1)
(57,83,1)
(18,99,1)
(71,19,1)
(82,98,1)
(98,84,1)
(76,27,1)
(25,14,1)
(76,47,1)
(75,35,1)
(78,56,1)
(93,78,1)
(24,44,1)
(99,108,1)
(109,52,1)
(63,42,1)
(37,108,1)
(20,87,1)
(15,75,1)
(86,25,1)
(59,49,1)
(47,2,1)
(38,18,1)
(104,92,1)
(54,99,1)
(29,63,1)
(14,56,1)
(102,27,1)
(43,37,1)
(1,97,1)
(8,1,1)
(74,9,1)
(14,108,1)
(84,63,1)
(9,51,1)
(8,60,1)
(44,72,1)
(53,73,1)
(57,46,1)
(57,79,1)
(22,56,1)
(10,15,1)
(22,72,1)
(16,90,1)
(0,43,1)
(14,72,1)
(44,67,1)
(67,58,1)
(66,89,1)
(78,108,1)
(90,70,1)
(89,29,1)
(50,27,1)
(37,62,2)
(8,25,2)
(95,22,2)
(111,22,2)
(78,103,2)
(37,108,2)
(89,63,2)
(93,78,2)
(97,108,2)
(97,30,2)
(56,53,2)
(112,15,2)
(49,27,2)
(44,67,2)
(9,4,2)
(100,37,2)
(44,22,2)
(1,25,2)
(93,37,2)
(44,108,2)
(37,72,2)
(33,99,2)
(46,37,2)
(103,37,2)
(50,25,2)
(14,56,2)
(78,37,2)
(54,99,2)
(98,37,2)
(27,25,2)
(42,37,2)
(109,15,2)
(10,15,2)
(31,44,2)
(43,37,2)
(2,25,2)
(8,1,2)
(53,35,2)
(83,37,2)
(4,104,2)
(14,108,2)
(66,89,2)
(50,27,2)
(35,99,2)
(97,25,2)
(7,37,2)
(72,99,2)
(90,99,2)
(25,14,2)
(76,27,2)
(94,15,2)
(34,37,2)
(62,22,2)
(1,97,2)
(27,8,2)
(49,25,2)
(82,37,2)
(9,37,2)
(70,99,2)
(104,93,2)
(63,37,2)
(58,22,2)
(104,92,2)
(30,25,2)
(23,76,2)
(104,37,2)
(63,4,2)
(102,25,2)
(75,35,2)
(16,99,2)
(74,37,2)
(97,72,2)
(67,22,2)
(26,23,2)
(86,25,2)
(37,22,2)
(47,25,2)
(15,75,2)
(64,25,2)
(59,25,2)
(4,37,2)
(76,25,2)
(78,108,2)
(40,22,2)
(51,37,2)
(0,37,2)
(44,72,2)
(15,99,2)
(53,15,2)
(73,15,2)
(83,4,2)
(25,22,2)
(75,99,2)
(8,60,2)
(29,63,2)
(78,72,2)
(38,99,2)
(20,25,2)
(37,56,2)
(52,15,2)
(87,25,2)
(102,27,2)
(36,25,2)
(18,99,2)
(24,44,2)
(80,76,2)
(79,25,2)
(14,72,2)
(44,56,2)
(13,99,2)
(56,15,2)
(26,76,2)
(84,37,2)
(66,63,2)
(25,44,2)
(97,56,2)
(14,44,2)
(78,56,2)
(81,25,2)
(28,25,2)
(82,4,2)
-----------------------------------
(0,data)
(1,malloc(data*sizeof(wchar_t)
(2,myString)
(3,myString)
(4,myString = (wchar_t *)
(5,)
(6,)
(7,wchar_t)
(8,(wchar_t *)
(9,printWLine(myString)
(10,"fgets()
(11,inputBuffer)
(12,if (data > wcslen(HELLO_STRING)
(13,NULL)
(14,data < 100)
(15,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(16,stdin)
(17,)
(18,data)
(19,data)
(20,HELLO_STRING)
(21,if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(22,globalReturnsTrueOrFalse()
(23,-1)
(24,data)
(25,data > wcslen(HELLO_STRING)
(26,exit(-1)
(27,myString = (wchar_t *)
(28,wchar_t)
(29,1)
(30,sizeof(wchar_t)
(31,100)
(32,)
(33,"")
(34,myString)
(35,inputBuffer[CHAR_ARRAY_SIZE] = "")
(36,myString)
(37,data > wcslen(HELLO_STRING)
(38,20)
(39,)
(40,data)
(41,data)
(42,NULL)
(43,myString)
(44,data > wcslen(HELLO_STRING)
(45,if (myString == NULL)
(46,printLine("Input is less than the length of the source string")
(47,NULL)
(48,myString)
(49,wcscpy(myString, HELLO_STRING)
(50,free(myString)
(51,myString)
(52,data)
(53,strtoul(inputBuffer, NULL, 0)
(54,inputBuffer)
(55,)
(56,data = strtoul(inputBuffer, NULL, 0)
(57,RET)
(58,HELLO_STRING)
(59,myString)
(60,wchar_t *)
(61,)
(62,wcslen(HELLO_STRING)
(63,myString == NULL)
(64,data)
(65,if (myString == NULL)
(66,exit(-1)
(67,wcslen(HELLO_STRING)
(68,)
(69,)
(70,inputBuffer)
(71,0)
(72,data = 20)
(73,0)
(74,myString)
(75,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(76,myString == NULL)
(77,)
(78,data*sizeof(wchar_t)
(79,printLine("Input is less than the length of the source string or too large")
(80,1)
(81,"Input is less than the length of the source string or too large")
(82,wcscpy(myString, HELLO_STRING)
(83,free(myString)
(84,myString)
(85,)
(86,myString)
(87,myString)
(88,)
(89,-1)
(90,CHAR_ARRAY_SIZE)
(91,)
(92,wchar_t *)
(93,malloc(data*sizeof(wchar_t)
(94,printLine("fgets()
(95,data)
(96,if (data > wcslen(HELLO_STRING)
(97,data*sizeof(wchar_t)
(98,HELLO_STRING)
(99,globalReturnsTrueOrFalse()
(100,"Input is less than the length of the source string")
(101,if(globalReturnsTrueOrFalse()
(102,printWLine(myString)
(103,sizeof(wchar_t)
(104,(wchar_t *)
(105,)
(106,)
(107,if(globalReturnsTrueOrFalse()
(108,data = 0)
(109,inputBuffer)
(110,)
(111,HELLO_STRING)
(112,NULL)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^