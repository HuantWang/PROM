-----label-----
1
-----code-----
void CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_12_bad()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printWLine((wchar_t *)structCharVoid->voidSecond);
            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printWLine((wchar_t *)structCharVoid->voidSecond);
            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
6,7
6,8
6,9
7,8
8,9
10,11
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
12,13
13,14
13,15
14,15
16,17
16,18
16,19
19,20
20,21
20,22
21,22
21,23
22,23
24,25
26,27
26,28
27,28
29,30
30,31
30,32
31,32
34,35
34,36
35,36
35,37
36,37
38,39
40,41
41,42
42,43
42,44
43,44
45,46
47,48
48,49
48,50
49,50
49,51
50,51
53,54
53,55
54,55
54,56
56,57
58,59
60,61
61,62
61,63
62,63
64,65
64,66
65,66
65,67
67,68
69,70
69,71
70,71
73,74
74,75
74,76
74,77
74,78
75,76
77,78
77,79
78,79
81,82
83,84
84,85
85,86
86,87
88,89
89,90
89,91
90,91
90,92
91,92
91,93
92,93
95,96
95,97
96,97
97,98
97,99
98,99
99,100
100,101
100,102
101,102
104,105
105,106
105,107
110,111
111,112
111,113
112,113
114,115
114,116
115,116
115,117
117,118
119,120
119,121
120,121
123,124
124,125
124,126
125,126
127,128
127,129
128,129
128,130
130,131
132,133
132,134
133,134
136,137
137,138
137,139
138,139
140,141
142,143
143,144
143,145
143,146
143,147
143,148
143,149
143,150
143,151
143,152
144,145
145,146
145,147
146,147
148,149
148,150
148,151
151,152
152,153
152,154
153,154
153,155
154,155
156,157
158,159
158,160
159,160
161,162
162,163
162,164
163,164
166,167
166,168
167,168
167,169
168,169
170,171
172,173
173,174
174,175
174,176
175,176
177,178
179,180
180,181
180,182
181,182
181,183
182,183
185,186
185,187
186,187
186,188
188,189
190,191
192,193
193,194
193,195
194,195
196,197
196,198
197,198
197,199
199,200
201,202
201,203
202,203
205,206
206,207
206,208
206,209
206,210
207,208
209,210
209,211
210,211
213,214
215,216
216,217
217,218
217,219
218,219
221,222
222,223
222,224
223,224
223,225
224,225
224,226
225,226
228,229
228,230
229,230
230,231
230,232
231,232
232,233
233,234
233,235
234,235
237,238
238,239
238,240
243,244
244,245
244,246
245,246
247,248
247,249
248,249
248,250
250,251
252,253
252,254
253,254
256,257
257,258
257,259
258,259
260,261
260,262
261,262
261,263
263,264
265,266
265,267
266,267
269,270
270,271
270,272
271,272
273,274
-----nextToken-----
2,4,9,15,17,18,23,25,28,32,33,37,39,44,46,51,52,55,57,59,63,66,68,71,72,76,79,80,82,87,93,94,102,103,106,107,108,109,113,116,118,121,122,126,129,131,134,135,139,141,147,149,150,155,157,160,164,165,169,171,176,178,183,184,187,189,191,195,198,200,203,204,208,211,212,214,219,220,226,227,235,236,239,240,241,242,246,249,251,254,255,259,262,264,267,268,272,274
-----computeFrom-----
35,36
35,37
48,49
48,50
89,90
89,91
95,96
95,97
97,98
97,99
167,168
167,169
180,181
180,182
222,223
222,224
228,229
228,230
230,231
230,232
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_12_bad(){    if(globalReturnsTrueOrFalse())    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }    else    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }}
void
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_12_bad()
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_12_bad
{    if(globalReturnsTrueOrFalse())    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }    else    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }}
if(globalReturnsTrueOrFalse())    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }    else    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }
{            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid
charVoid
* structCharVoid = (charVoid *)malloc(sizeof(charVoid))
*
structCharVoid
= (charVoid *)malloc(sizeof(charVoid))
(charVoid *)malloc(sizeof(charVoid))
charVoid *
charVoid
charVoid
*
*
malloc(sizeof(charVoid))
malloc
malloc
sizeof(charVoid)
charVoid
charVoid
charVoid

if (structCharVoid == NULL) {exit(-1);}
structCharVoid == NULL
structCharVoid
structCharVoid
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
structCharVoid->voidSecond = (void *)SRC_STR;
structCharVoid->voidSecond = (void *)SRC_STR
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
(void *)SRC_STR
void *
void
*
*
SRC_STR
SRC_STR
printWLine((wchar_t *)structCharVoid->voidSecond);
printWLine((wchar_t *)structCharVoid->voidSecond)
printWLine
printWLine
(wchar_t *)structCharVoid->voidSecond
wchar_t *
wchar_t
*
*
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid))
memcpy
memcpy
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
SRC_STR
SRC_STR
sizeof(*structCharVoid)
(*structCharVoid)
*structCharVoid
structCharVoid
structCharVoid
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0';
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1]
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1
(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))
sizeof(structCharVoid->charFirst)/sizeof(wchar_t)
sizeof(structCharVoid->charFirst)
(structCharVoid->charFirst)
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
sizeof(wchar_t)
wchar_t
wchar_t

1
L'\0'
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->charFirst)
printWLine
printWLine
(wchar_t *)structCharVoid->charFirst
wchar_t *
wchar_t
*
*
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
printWLine((wchar_t *)structCharVoid->voidSecond);
printWLine((wchar_t *)structCharVoid->voidSecond)
printWLine
printWLine
(wchar_t *)structCharVoid->voidSecond
wchar_t *
wchar_t
*
*
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
free(structCharVoid);
free(structCharVoid)
free
free
structCharVoid
structCharVoid
{        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }
{            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid
charVoid
* structCharVoid = (charVoid *)malloc(sizeof(charVoid))
*
structCharVoid
= (charVoid *)malloc(sizeof(charVoid))
(charVoid *)malloc(sizeof(charVoid))
charVoid *
charVoid
charVoid
*
*
malloc(sizeof(charVoid))
malloc
malloc
sizeof(charVoid)
charVoid
charVoid
charVoid

if (structCharVoid == NULL) {exit(-1);}
structCharVoid == NULL
structCharVoid
structCharVoid
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
structCharVoid->voidSecond = (void *)SRC_STR;
structCharVoid->voidSecond = (void *)SRC_STR
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
(void *)SRC_STR
void *
void
*
*
SRC_STR
SRC_STR
printWLine((wchar_t *)structCharVoid->voidSecond);
printWLine((wchar_t *)structCharVoid->voidSecond)
printWLine
printWLine
(wchar_t *)structCharVoid->voidSecond
wchar_t *
wchar_t
*
*
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst))
memcpy
memcpy
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
SRC_STR
SRC_STR
sizeof(structCharVoid->charFirst)
(structCharVoid->charFirst)
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0';
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1]
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1
(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))
sizeof(structCharVoid->charFirst)/sizeof(wchar_t)
sizeof(structCharVoid->charFirst)
(structCharVoid->charFirst)
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
sizeof(wchar_t)
wchar_t
wchar_t

1
L'\0'
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->charFirst)
printWLine
printWLine
(wchar_t *)structCharVoid->charFirst
wchar_t *
wchar_t
*
*
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
printWLine((wchar_t *)structCharVoid->voidSecond);
printWLine((wchar_t *)structCharVoid->voidSecond)
printWLine
printWLine
(wchar_t *)structCharVoid->voidSecond
wchar_t *
wchar_t
*
*
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
free(structCharVoid);
free(structCharVoid)
free
free
structCharVoid
structCharVoid
-----joern-----
(80,91,0)
(58,44,0)
(75,93,0)
(73,106,0)
(99,53,0)
(83,77,0)
(105,114,0)
(17,62,0)
(85,90,0)
(89,64,0)
(68,58,0)
(70,15,0)
(95,77,0)
(48,30,0)
(81,24,0)
(104,19,0)
(11,27,0)
(12,92,0)
(88,48,0)
(78,92,0)
(109,98,0)
(29,82,0)
(26,36,0)
(77,62,0)
(21,18,0)
(93,13,0)
(27,11,0)
(31,11,0)
(19,32,0)
(20,6,0)
(16,25,0)
(45,94,0)
(14,90,0)
(54,98,0)
(58,94,0)
(39,18,0)
(103,15,0)
(64,89,0)
(31,61,0)
(43,73,0)
(51,63,0)
(109,11,0)
(60,71,0)
(94,58,0)
(3,15,0)
(101,24,0)
(37,34,0)
(48,84,0)
(53,106,0)
(90,14,0)
(5,24,0)
(35,114,0)
(6,63,0)
(42,109,0)
(13,93,0)
(52,45,0)
(91,14,0)
(28,12,0)
(112,31,0)
(61,46,0)
(92,12,0)
(13,72,0)
(9,82,0)
(57,65,0)
(84,48,0)
(8,0,0)
(39,63,0)
(106,90,0)
(63,100,0)
(107,34,0)
(102,109,0)
(40,67,0)
(110,12,0)
(33,92,0)
(6,20,0)
(54,15,0)
(93,84,0)
(22,93,0)
(38,31,0)
(56,53,0)
(30,48,0)
(24,106,0)
(27,74,0)
(31,84,0)
(53,18,0)
(109,84,0)
(11,15,0)
(36,72,0)
(25,84,0)
(71,84,0)
(30,67,0)
(108,63,0)
(18,39,0)
(61,31,0)
(113,98,0)
(106,63,0)
(24,81,0)
(71,15,0)
(46,61,0)
(55,63,0)
(98,54,0)
(64,15,0)
(84,15,0)
(2,15,0)
(67,30,0)
(87,25,0)
(62,63,0)
(0,57,0)
(92,33,0)
(108,106,0)
(34,106,0)
(89,25,0)
(103,61,0)
(20,34,0)
(33,63,0)
(7,106,0)
(111,108,0)
(18,53,0)
(57,0,0)
(82,84,0)
(90,85,0)
(4,20,0)
(34,20,0)
(15,47,0)
(94,63,0)
(50,63,0)
(13,15,0)
(36,84,0)
(86,104,0)
(90,106,0)
(53,94,0)
(72,36,0)
(79,89,0)
(92,78,0)
(98,113,0)
(114,11,0)
(61,103,0)
(62,81,0)
(49,13,0)
(69,27,0)
(25,89,0)
(62,77,0)
(72,13,0)
(18,21,0)
(74,27,0)
(66,45,0)
(89,79,0)
(14,91,0)
(34,94,0)
(12,106,0)
(114,84,0)
(48,88,0)
(81,62,0)
(20,4,0)
(19,104,0)
(44,58,0)
(77,106,0)
(10,41,0)
(98,109,0)
(1,84,0)
(45,106,0)
(59,73,0)
(27,69,1)
(13,72,1)
(89,79,1)
(17,77,1)
(57,0,1)
(13,93,1)
(106,90,1)
(16,3,1)
(5,17,1)
(53,106,1)
(89,25,1)
(48,88,1)
(71,84,1)
(58,44,1)
(20,34,1)
(52,57,1)
(40,1,1)
(38,112,1)
(109,11,1)
(81,24,1)
(93,84,1)
(36,84,1)
(34,37,1)
(48,30,1)
(93,22,1)
(31,38,1)
(112,64,1)
(11,27,1)
(77,95,1)
(49,93,1)
(108,111,1)
(60,103,1)
(3,13,1)
(75,54,1)
(77,106,1)
(114,84,1)
(53,99,1)
(80,7,1)
(18,53,1)
(111,6,1)
(92,12,1)
(66,52,1)
(39,18,1)
(22,75,1)
(68,45,1)
(84,48,1)
(42,11,1)
(97,71,1)
(105,82,1)
(90,14,1)
(27,74,1)
(90,85,1)
(24,106,1)
(35,105,1)
(58,68,1)
(59,106,1)
(25,87,1)
(12,106,1)
(52,73,1)
(8,73,1)
(26,49,1)
(20,4,1)
(62,77,1)
(34,94,1)
(72,36,1)
(7,23,1)
(99,56,1)
(82,84,1)
(61,31,1)
(94,58,1)
(67,40,1)
(29,84,1)
(95,83,1)
(87,16,1)
(36,26,1)
(114,35,1)
(103,61,1)
(0,8,1)
(24,101,1)
(110,50,1)
(30,67,1)
(33,92,1)
(98,113,1)
(37,107,1)
(109,84,1)
(56,94,1)
(50,62,1)
(104,86,1)
(1,23,1)
(45,66,1)
(82,9,1)
(102,42,1)
(101,5,1)
(97,108,1)
(53,94,1)
(31,11,1)
(73,106,1)
(31,84,1)
(92,78,1)
(12,28,1)
(86,82,1)
(19,104,1)
(108,106,1)
(83,39,1)
(105,19,1)
(73,43,1)
(14,91,1)
(34,106,1)
(25,84,1)
(9,29,1)
(109,102,1)
(18,21,1)
(61,46,1)
(6,20,1)
(62,81,1)
(43,59,1)
(71,60,1)
(98,109,1)
(28,110,1)
(54,98,1)
(107,33,1)
(91,80,1)
(64,89,1)
(45,106,1)
(69,114,1)
(14,23,2)
(90,14,2)
(24,106,2)
(7,23,2)
(108,106,2)
(18,21,2)
(86,82,2)
(68,23,2)
(67,23,2)
(61,31,2)
(24,23,2)
(90,85,2)
(111,23,2)
(31,84,2)
(6,23,2)
(89,79,2)
(80,23,2)
(110,23,2)
(77,106,2)
(48,88,2)
(13,72,2)
(92,23,2)
(20,23,2)
(37,23,2)
(12,106,2)
(71,23,2)
(36,84,2)
(90,23,2)
(94,23,2)
(0,73,2)
(29,23,2)
(11,27,2)
(52,23,2)
(81,24,2)
(73,106,2)
(89,23,2)
(30,67,2)
(31,23,2)
(73,23,2)
(18,23,2)
(43,23,2)
(13,93,2)
(19,104,2)
(62,81,2)
(34,23,2)
(27,23,2)
(22,23,2)
(62,77,2)
(20,4,2)
(87,23,2)
(16,23,2)
(108,23,2)
(53,94,2)
(109,23,2)
(19,82,2)
(54,23,2)
(1,23,2)
(66,23,2)
(12,23,2)
(20,34,2)
(95,23,2)
(89,25,2)
(91,23,2)
(84,23,2)
(8,73,2)
(62,23,2)
(39,18,2)
(13,23,2)
(92,12,2)
(42,23,2)
(109,11,2)
(112,23,2)
(48,30,2)
(94,58,2)
(54,98,2)
(106,90,2)
(38,23,2)
(64,23,2)
(64,89,2)
(31,11,2)
(58,44,2)
(30,23,2)
(72,36,2)
(82,84,2)
(53,106,2)
(28,23,2)
(58,23,2)
(61,23,2)
(48,23,2)
(50,23,2)
(25,23,2)
(53,23,2)
(49,23,2)
(33,23,2)
(27,74,2)
(59,23,2)
(102,23,2)
(9,23,2)
(45,23,2)
(109,84,2)
(98,113,2)
(56,23,2)
(98,23,2)
(83,23,2)
(60,23,2)
(99,23,2)
(77,23,2)
(14,91,2)
(36,23,2)
(114,84,2)
(57,73,2)
(98,109,2)
(6,20,2)
(5,23,2)
(82,23,2)
(18,53,2)
(103,61,2)
(17,23,2)
(40,23,2)
(34,106,2)
(81,23,2)
(25,84,2)
(106,23,2)
(33,92,2)
(57,0,2)
(114,23,2)
(103,23,2)
(93,84,2)
(105,23,2)
(101,23,2)
(71,84,2)
(84,48,2)
(61,46,2)
(75,23,2)
(93,23,2)
(3,23,2)
(26,23,2)
(39,23,2)
(92,78,2)
(107,23,2)
(35,23,2)
(11,23,2)
(69,23,2)
(34,94,2)
(72,23,2)
(104,82,2)
(45,106,2)
-----------------------------------
(0,-1)
(1,structCharVoid)
(2,structCharVoid)
(3,'\\\\0')
(4,wchar_t *)
(5,structCharVoid)
(6,printWLine((wchar_t *)
(7,structCharVoid)
(8,1)
(9,NULL)
(10,if(globalReturnsTrueOrFalse()
(11,structCharVoid->voidSecond = (void *)
(12,structCharVoid->charFirst)
(13,memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)
(14,malloc(sizeof(charVoid)
(15,)
(16,structCharVoid)
(17,SRC_STR)
(18,(wchar_t *)
(19,exit(-1)
(20,(wchar_t *)
(21,wchar_t *)
(22,charFirst)
(23,globalReturnsTrueOrFalse()
(24,structCharVoid->charFirst)
(25,structCharVoid->charFirst)
(26,structCharVoid)
(27,(void *)
(28,charFirst)
(29,structCharVoid)
(30,malloc(sizeof(charVoid)
(31,structCharVoid->voidSecond)
(32,)
(33,printWLine((wchar_t *)
(34,structCharVoid->voidSecond)
(35,voidSecond)
(36,*structCharVoid)
(37,voidSecond)
(38,voidSecond)
(39,printWLine((wchar_t *)
(40,charVoid)
(41,)
(42,structCharVoid)
(43,NULL)
(44,void *)
(45,structCharVoid->voidSecond)
(46,wchar_t *)
(47,)
(48,(charVoid *)
(49,SRC_STR)
(50,\'\\\\0\')
(51,if (structCharVoid == NULL)
(52,structCharVoid)
(53,structCharVoid->voidSecond)
(54,printWLine((wchar_t *)
(55,structCharVoid)
(56,structCharVoid)
(57,exit(-1)
(58,(void *)
(59,structCharVoid)
(60,structCharVoid)
(61,(wchar_t *)
(62,memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)
(63,)
(64,printWLine((wchar_t *)
(65,)
(66,voidSecond)
(67,sizeof(charVoid)
(68,SRC_STR)
(69,SRC_STR)
(70,if (structCharVoid == NULL)
(71,free(structCharVoid)
(72,sizeof(*structCharVoid)
(73,structCharVoid == NULL)
(74,void *)
(75,structCharVoid)
(76,\'\\\\0\')
(77,structCharVoid->charFirst)
(78,wchar_t *)
(79,wchar_t *)
(80,charVoid)
(81,sizeof(structCharVoid->charFirst)
(82,structCharVoid == NULL)
(83,structCharVoid)
(84,* structCharVoid = (charVoid *)
(85,charVoid *)
(86,1)
(87,charFirst)
(88,charVoid *)
(89,(wchar_t *)
(90,(charVoid *)
(91,sizeof(charVoid)
(92,(wchar_t *)
(93,structCharVoid->charFirst)
(94,structCharVoid->voidSecond = (void *)
(95,charFirst)
(96,'\\\\0')
(97,RET)
(98,(wchar_t *)
(99,voidSecond)
(100,)
(101,charFirst)
(102,voidSecond)
(103,printWLine((wchar_t *)
(104,-1)
(105,structCharVoid)
(106,* structCharVoid = (charVoid *)
(107,structCharVoid)
(108,free(structCharVoid)
(109,structCharVoid->voidSecond)
(110,structCharVoid)
(111,structCharVoid)
(112,structCharVoid)
(113,wchar_t *)
(114,structCharVoid->voidSecond)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^