-----label-----
1
-----code-----
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_32_bad()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0]);
                free(data);
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
9,10
9,11
12,13
13,14
13,15
15,16
15,17
15,18
15,19
19,20
20,21
21,22
23,24
24,25
24,26
26,27
26,28
26,29
26,30
30,31
31,32
32,33
34,35
35,36
35,37
36,37
38,39
40,41
40,42
40,43
40,44
41,42
42,43
42,44
44,45
44,46
44,47
47,48
48,49
49,50
51,52
52,53
52,54
53,54
55,56
55,57
56,57
56,58
58,59
60,61
60,62
61,62
63,64
63,65
65,66
66,67
66,68
69,70
69,71
70,71
70,72
71,72
73,74
75,76
76,77
77,78
77,79
78,79
80,81
82,83
83,84
83,85
84,85
85,86
87,88
89,90
89,91
90,91
91,92
91,93
93,94
93,95
93,96
96,97
97,98
98,99
100,101
100,102
101,102
102,103
102,104
104,105
104,106
104,107
106,107
108,109
109,110
111,112
111,113
111,114
111,115
112,113
113,114
113,115
114,115
116,117
118,119
118,120
118,121
118,122
119,120
120,121
120,122
121,122
124,125
124,126
125,126
128,129
129,130
131,132
132,133
133,134
133,135
134,135
134,136
135,136
137,138
139,140
139,141
140,141
142,143
144,145
145,146
145,147
146,147
148,149
148,150
149,150
152,153
153,154
153,155
154,155
156,157
-----nextToken-----
2,4,8,10,11,14,16,17,18,22,25,27,28,29,33,37,39,43,45,46,50,54,57,59,62,64,67,68,72,74,79,81,86,88,92,94,95,99,103,105,107,110,115,117,122,123,126,127,130,136,138,141,143,147,150,151,155,157
-----computeFrom-----
35,36
35,37
52,53
52,54
63,64
63,65
70,71
70,72
83,84
83,85
120,121
120,122
124,125
124,126
133,134
133,135
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;EqualsInitializer;InitializerList;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_32_bad(){    int * data;    int * *dataPtr1 = &data;    int * *dataPtr2 = &data;    data = NULL;    {        int * data = *dataPtr1;        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (int *)malloc(50*sizeof(int));        if (data == NULL) {exit(-1);}        *dataPtr1 = data;    }    {        int * data = *dataPtr2;        {            int source[100] = {0}; /* fill with 0's */            {                size_t i;                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */                for (i = 0; i < 100; i++)                {                    data[i] = source[i];                }                printIntLine(data[0]);                free(data);            }        }    }}
void
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_32_bad()
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_32_bad
{    int * data;    int * *dataPtr1 = &data;    int * *dataPtr2 = &data;    data = NULL;    {        int * data = *dataPtr1;        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (int *)malloc(50*sizeof(int));        if (data == NULL) {exit(-1);}        *dataPtr1 = data;    }    {        int * data = *dataPtr2;        {            int source[100] = {0}; /* fill with 0's */            {                size_t i;                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */                for (i = 0; i < 100; i++)                {                    data[i] = source[i];                }                printIntLine(data[0]);                free(data);            }        }    }}
int * data;
int * data;
int
* data
*
data
int * *dataPtr1 = &data;
int * *dataPtr1 = &data;
int
* *dataPtr1 = &data
*
*
dataPtr1
= &data
&data
data
data
int * *dataPtr2 = &data;
int * *dataPtr2 = &data;
int
* *dataPtr2 = &data
*
*
dataPtr2
= &data
&data
data
data
data = NULL;
data = NULL
data
data
NULL
NULL
{        int * data = *dataPtr1;        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (int *)malloc(50*sizeof(int));        if (data == NULL) {exit(-1);}        *dataPtr1 = data;    }
int * data = *dataPtr1;
int * data = *dataPtr1;
int
* data = *dataPtr1
*
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
data = (int *)malloc(50*sizeof(int));
data = (int *)malloc(50*sizeof(int))
data
data
(int *)malloc(50*sizeof(int))
int *
int
*
*
malloc(50*sizeof(int))
malloc
malloc
50*sizeof(int)
50
sizeof(int)
int
int

if (data == NULL) {exit(-1);}
data == NULL
data
data
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        int * data = *dataPtr2;        {            int source[100] = {0}; /* fill with 0's */            {                size_t i;                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */                for (i = 0; i < 100; i++)                {                    data[i] = source[i];                }                printIntLine(data[0]);                free(data);            }        }    }
int * data = *dataPtr2;
int * data = *dataPtr2;
int
* data = *dataPtr2
*
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
{            int source[100] = {0}; /* fill with 0's */            {                size_t i;                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */                for (i = 0; i < 100; i++)                {                    data[i] = source[i];                }                printIntLine(data[0]);                free(data);            }        }
int source[100] = {0};
int source[100] = {0};
int
source[100] = {0}
source
[100]
100
= {0}
{0}
0
{                size_t i;                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */                for (i = 0; i < 100; i++)                {                    data[i] = source[i];                }                printIntLine(data[0]);                free(data);            }
size_t i;
size_t i;
size_t
size_t
i
i
for (i = 0; i < 100; i++)                {                    data[i] = source[i];                }
i = 0;
i = 0
i
i
0
i < 100
i
i
100
i++
i
i
{                    data[i] = source[i];                }
data[i] = source[i];
data[i] = source[i]
data[i]
data
data
i
i
source[i]
source
source
i
i
printIntLine(data[0]);
printIntLine(data[0])
printIntLine
printIntLine
data[0]
data
data
0
free(data);
free(data)
free
free
data
data
-----joern-----
(58,72,0)
(18,22,0)
(21,27,0)
(12,31,0)
(64,41,0)
(73,45,0)
(74,23,0)
(40,2,0)
(45,57,0)
(59,33,0)
(13,8,0)
(65,23,0)
(10,8,0)
(16,8,0)
(21,57,0)
(44,8,0)
(48,29,0)
(41,64,0)
(27,21,0)
(17,64,0)
(29,51,0)
(11,41,0)
(26,46,0)
(0,22,0)
(50,21,0)
(68,52,0)
(35,22,0)
(66,35,0)
(14,8,0)
(5,69,0)
(45,21,0)
(2,8,0)
(27,32,0)
(43,22,0)
(36,31,0)
(29,59,0)
(23,57,0)
(70,33,0)
(24,2,0)
(77,44,0)
(35,51,0)
(20,59,0)
(60,24,0)
(47,13,0)
(49,38,0)
(35,19,0)
(34,27,0)
(51,35,0)
(53,57,0)
(52,22,0)
(71,31,0)
(29,22,0)
(7,69,0)
(75,43,0)
(72,58,0)
(64,34,0)
(27,34,0)
(56,65,0)
(46,59,0)
(63,19,0)
(62,29,0)
(34,64,0)
(33,8,0)
(65,44,0)
(55,2,0)
(36,20,0)
(38,45,0)
(42,40,0)
(28,33,0)
(2,40,0)
(9,72,0)
(30,13,0)
(20,36,0)
(57,8,0)
(46,31,0)
(25,20,0)
(67,20,0)
(58,37,0)
(1,54,0)
(24,59,0)
(69,21,0)
(23,65,0)
(51,15,0)
(19,28,0)
(44,54,0)
(54,44,0)
(61,59,0)
(38,44,0)
(6,35,0)
(4,57,0)
(59,24,0)
(32,27,0)
(39,28,0)
(31,28,0)
(76,52,0)
(49,58,1)
(75,51,1)
(17,50,1)
(56,74,1)
(45,73,1)
(38,44,1)
(52,68,1)
(67,25,1)
(43,75,1)
(0,18,1)
(13,30,1)
(1,77,1)
(41,11,1)
(74,13,1)
(55,44,1)
(24,60,1)
(29,22,1)
(36,20,1)
(47,2,1)
(29,48,1)
(20,59,1)
(76,43,1)
(7,21,1)
(69,5,1)
(2,40,1)
(11,17,1)
(72,9,1)
(27,32,1)
(61,45,1)
(20,67,1)
(63,59,1)
(66,6,1)
(43,22,1)
(54,1,1)
(35,22,1)
(44,54,1)
(58,72,1)
(18,19,1)
(51,35,1)
(26,36,1)
(48,62,1)
(45,21,1)
(40,42,1)
(24,2,1)
(30,47,1)
(73,38,1)
(42,55,1)
(35,66,1)
(9,69,1)
(46,26,1)
(25,52,1)
(3,46,1)
(76,22,1)
(65,56,1)
(29,59,1)
(50,23,1)
(5,7,1)
(38,49,1)
(68,76,1)
(34,64,1)
(6,29,1)
(49,69,1)
(65,44,1)
(27,34,1)
(60,61,1)
(23,65,1)
(35,19,1)
(22,0,1)
(21,27,1)
(62,52,1)
(46,59,1)
(64,41,1)
(59,24,1)
(52,22,1)
(19,63,1)
(69,21,1)
(43,22,2)
(43,52,2)
(35,19,2)
(66,52,2)
(65,44,2)
(23,65,2)
(46,59,2)
(38,44,2)
(9,69,2)
(21,27,2)
(35,52,2)
(68,52,2)
(48,52,2)
(62,52,2)
(69,21,2)
(2,40,2)
(6,52,2)
(20,59,2)
(51,52,2)
(76,52,2)
(27,34,2)
(29,59,2)
(24,2,2)
(29,22,2)
(44,54,2)
(51,35,2)
(52,22,2)
(36,20,2)
(64,41,2)
(29,52,2)
(52,52,2)
(58,69,2)
(45,21,2)
(35,22,2)
(34,64,2)
(59,24,2)
(58,72,2)
(27,32,2)
(72,69,2)
(75,52,2)
-----------------------------------
(0,0)
(1,data)
(2,* *dataPtr2 = &data)
(3,RET)
(4,if (data == NULL)
(5,NULL)
(6,source)
(7,data)
(8,)
(9,1)
(10,dataPtr1)
(11,int)
(12,for (i = 0; i < 100; i++)
(13,data = NULL)
(14,data)
(15,)
(16,dataPtr2)
(17,50)
(18,i)
(19,source[100] = {0})
(20,data[0])
(21,data = (int *)
(22,i = 0)
(23,* data = *dataPtr1)
(24,*dataPtr2)
(25,data)
(26,data)
(27,(int *)
(28,)
(29,data[i])
(30,NULL)
(31,)
(32,int *)
(33,)
(34,malloc(50*sizeof(int)
(35,source[i])
(36,printIntLine(data[0])
(37,)
(38,*dataPtr1)
(39,source)
(40,&data)
(41,sizeof(int)
(42,data)
(43,i++)
(44,* *dataPtr1 = &data)
(45,*dataPtr1 = data)
(46,free(data)
(47,data)
(48,i)
(49,dataPtr1)
(50,data)
(51,data[i] = source[i])
(52,i < 100)
(53,data)
(54,&data)
(55,dataPtr2)
(56,dataPtr1)
(57,)
(58,exit(-1)
(59,* data = *dataPtr2)
(60,dataPtr2)
(61,data)
(62,data)
(63,source)
(64,50*sizeof(int)
(65,*dataPtr1)
(66,i)
(67,0)
(68,100)
(69,data == NULL)
(70,data)
(71,i)
(72,-1)
(73,data)
(74,data)
(75,i)
(76,i)
(77,dataPtr1)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^