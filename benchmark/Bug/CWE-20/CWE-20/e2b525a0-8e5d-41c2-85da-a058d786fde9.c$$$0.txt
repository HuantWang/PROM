-----label-----
1
-----code-----
void CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17_bad()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printWLine((wchar_t *)structCharVoid->voidSecond);
            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
6,7
7,8
7,9
9,10
11,12
11,13
11,14
11,15
12,13
13,14
13,15
14,15
17,18
17,19
18,19
21,22
22,23
24,25
25,26
25,27
25,28
25,29
25,30
25,31
25,32
25,33
25,34
26,27
27,28
27,29
28,29
30,31
30,32
30,33
33,34
34,35
34,36
35,36
35,37
36,37
38,39
40,41
40,42
41,42
43,44
44,45
44,46
45,46
48,49
48,50
49,50
49,51
50,51
52,53
54,55
55,56
56,57
56,58
57,58
59,60
61,62
62,63
62,64
63,64
63,65
64,65
67,68
67,69
68,69
68,70
70,71
72,73
74,75
75,76
75,77
76,77
78,79
78,80
79,80
79,81
81,82
83,84
83,85
84,85
87,88
88,89
88,90
88,91
88,92
89,90
91,92
91,93
92,93
95,96
97,98
98,99
99,100
100,101
102,103
103,104
103,105
104,105
104,106
105,106
105,107
106,107
109,110
109,111
110,111
111,112
111,113
112,113
113,114
114,115
114,116
115,116
118,119
119,120
119,121
124,125
125,126
125,127
126,127
128,129
128,130
129,130
129,131
131,132
133,134
133,135
134,135
137,138
138,139
138,140
139,140
141,142
141,143
142,143
142,144
144,145
146,147
146,148
147,148
150,151
151,152
151,153
152,153
154,155
-----nextToken-----
2,4,8,10,15,16,19,20,23,29,31,32,37,39,42,46,47,51,53,58,60,65,66,69,71,73,77,80,82,85,86,90,93,94,96,101,107,108,116,117,120,121,122,123,127,130,132,135,136,140,143,145,148,149,153,155
-----computeFrom-----
13,14
13,15
17,18
17,19
49,50
49,51
62,63
62,64
103,104
103,105
109,110
109,111
111,112
111,113
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17_bad(){    int j;    for(j = 0; j < 1; j++)    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }}
void
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17_bad()
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17_bad
{    int j;    for(j = 0; j < 1; j++)    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }}
int j;
int j;
int
j
j
for(j = 0; j < 1; j++)    {        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }
j = 0;
j = 0
j
j
0
j < 1
j
j
1
j++
j
j
{        {            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }    }
{            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));            if (structCharVoid == NULL) {exit(-1);}            structCharVoid->voidSecond = (void *)SRC_STR;            /* Print the initial block pointed to by structCharVoid->voidSecond */            printWLine((wchar_t *)structCharVoid->voidSecond);            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */            printWLine((wchar_t *)structCharVoid->charFirst);            printWLine((wchar_t *)structCharVoid->voidSecond);            free(structCharVoid);        }
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid
charVoid
* structCharVoid = (charVoid *)malloc(sizeof(charVoid))
*
structCharVoid
= (charVoid *)malloc(sizeof(charVoid))
(charVoid *)malloc(sizeof(charVoid))
charVoid *
charVoid
charVoid
*
*
malloc(sizeof(charVoid))
malloc
malloc
sizeof(charVoid)
charVoid
charVoid
charVoid

if (structCharVoid == NULL) {exit(-1);}
structCharVoid == NULL
structCharVoid
structCharVoid
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
structCharVoid->voidSecond = (void *)SRC_STR;
structCharVoid->voidSecond = (void *)SRC_STR
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
(void *)SRC_STR
void *
void
*
*
SRC_STR
SRC_STR
printWLine((wchar_t *)structCharVoid->voidSecond);
printWLine((wchar_t *)structCharVoid->voidSecond)
printWLine
printWLine
(wchar_t *)structCharVoid->voidSecond
wchar_t *
wchar_t
*
*
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid))
memcpy
memcpy
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
SRC_STR
SRC_STR
sizeof(*structCharVoid)
(*structCharVoid)
*structCharVoid
structCharVoid
structCharVoid
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0';
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1]
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1
(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))
sizeof(structCharVoid->charFirst)/sizeof(wchar_t)
sizeof(structCharVoid->charFirst)
(structCharVoid->charFirst)
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
sizeof(wchar_t)
wchar_t
wchar_t

1
L'\0'
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->charFirst)
printWLine
printWLine
(wchar_t *)structCharVoid->charFirst
wchar_t *
wchar_t
*
*
structCharVoid->charFirst
structCharVoid
structCharVoid
charFirst
printWLine((wchar_t *)structCharVoid->voidSecond);
printWLine((wchar_t *)structCharVoid->voidSecond)
printWLine
printWLine
(wchar_t *)structCharVoid->voidSecond
wchar_t *
wchar_t
*
*
structCharVoid->voidSecond
structCharVoid
structCharVoid
voidSecond
free(structCharVoid);
free(structCharVoid)
free
free
structCharVoid
structCharVoid
-----joern-----
(18,21,0)
(46,25,0)
(26,62,0)
(54,60,0)
(51,30,0)
(12,2,0)
(40,43,0)
(58,0,0)
(1,50,0)
(32,43,0)
(26,41,0)
(64,50,0)
(22,43,0)
(41,26,0)
(12,29,0)
(31,15,0)
(63,25,0)
(16,41,0)
(30,18,0)
(9,25,0)
(44,22,0)
(47,23,0)
(29,12,0)
(60,22,0)
(47,46,0)
(19,22,0)
(31,46,0)
(6,60,0)
(65,23,0)
(0,14,0)
(60,12,0)
(46,21,0)
(55,66,0)
(7,47,0)
(15,31,0)
(20,8,0)
(45,1,0)
(66,63,0)
(12,60,0)
(11,25,0)
(28,10,0)
(43,22,0)
(24,19,0)
(13,19,0)
(8,46,0)
(15,23,0)
(39,64,0)
(23,47,0)
(19,66,0)
(23,25,0)
(21,46,0)
(63,66,0)
(22,25,0)
(18,30,0)
(25,34,0)
(8,25,0)
(14,61,0)
(27,47,0)
(38,26,0)
(48,50,0)
(41,46,0)
(42,36,0)
(52,25,0)
(26,38,0)
(21,18,0)
(38,25,0)
(59,44,0)
(37,1,0)
(35,46,0)
(2,12,0)
(19,46,0)
(66,19,0)
(57,10,0)
(21,49,0)
(14,0,0)
(2,25,0)
(44,46,0)
(43,32,0)
(66,55,0)
(33,50,0)
(56,36,0)
(23,15,0)
(49,21,0)
(36,46,0)
(60,46,0)
(5,44,0)
(3,31,0)
(62,26,0)
(4,41,0)
(16,4,1)
(43,32,1)
(7,27,1)
(24,22,1)
(63,66,1)
(1,50,1)
(6,54,1)
(23,15,1)
(11,23,1)
(59,5,1)
(47,46,1)
(51,35,1)
(45,64,1)
(31,46,1)
(22,43,1)
(20,2,1)
(8,46,1)
(46,21,1)
(8,20,1)
(19,46,1)
(36,56,1)
(44,46,1)
(0,58,1)
(21,49,1)
(58,36,1)
(18,30,1)
(15,31,1)
(65,47,1)
(26,41,1)
(35,1,1)
(66,19,1)
(14,0,1)
(1,37,1)
(48,33,1)
(41,16,1)
(60,46,1)
(54,38,1)
(50,48,1)
(66,55,1)
(5,36,1)
(56,42,1)
(23,47,1)
(41,46,1)
(19,13,1)
(47,7,1)
(43,40,1)
(17,1,1)
(37,45,1)
(60,6,1)
(3,65,1)
(42,46,1)
(5,14,1)
(31,3,1)
(38,26,1)
(27,63,1)
(36,46,1)
(30,51,1)
(39,8,1)
(40,44,1)
(21,18,1)
(45,50,1)
(64,39,1)
(19,22,1)
(12,29,1)
(44,59,1)
(26,62,1)
(60,22,1)
(4,11,1)
(13,24,1)
(2,12,1)
(64,50,1)
(12,60,1)
(38,26,2)
(26,1,2)
(20,1,2)
(47,46,2)
(46,1,2)
(21,18,2)
(18,30,2)
(21,1,2)
(12,60,2)
(27,1,2)
(37,1,2)
(12,29,2)
(64,1,2)
(2,12,2)
(64,50,2)
(44,1,2)
(63,66,2)
(41,46,2)
(23,15,2)
(8,46,2)
(19,22,2)
(35,1,2)
(1,50,2)
(66,55,2)
(45,1,2)
(63,1,2)
(30,1,2)
(21,49,2)
(8,1,2)
(51,1,2)
(0,36,2)
(26,62,2)
(41,1,2)
(4,1,2)
(14,36,2)
(23,47,2)
(31,46,2)
(12,1,2)
(22,1,2)
(3,1,2)
(38,1,2)
(60,46,2)
(11,1,2)
(66,19,2)
(14,0,2)
(16,1,2)
(5,1,2)
(31,1,2)
(24,1,2)
(15,1,2)
(26,41,2)
(36,46,2)
(60,22,2)
(19,1,2)
(47,1,2)
(22,43,2)
(56,1,2)
(23,1,2)
(7,1,2)
(43,1,2)
(6,1,2)
(18,1,2)
(43,32,2)
(44,46,2)
(46,21,2)
(59,1,2)
(13,1,2)
(15,31,2)
(2,1,2)
(65,1,2)
(1,1,2)
(60,1,2)
(58,36,2)
(54,1,2)
(40,1,2)
(39,1,2)
(42,1,2)
(66,1,2)
(19,46,2)
(36,1,2)
-----------------------------------
(0,-1)
(1,j < 1)
(2,printWLine((wchar_t *)
(3,structCharVoid)
(4,structCharVoid)
(5,structCharVoid)
(6,voidSecond)
(7,charFirst)
(8,free(structCharVoid)
(9,if (structCharVoid == NULL)
(10,)
(11,\'\\\\0\')
(12,(wchar_t *)
(13,voidSecond)
(14,exit(-1)
(15,sizeof(*structCharVoid)
(16,charFirst)
(17,RET)
(18,malloc(sizeof(charVoid)
(19,structCharVoid->voidSecond)
(20,structCharVoid)
(21,(charVoid *)
(22,structCharVoid->voidSecond = (void *)
(23,memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)
(24,structCharVoid)
(25,)
(26,(wchar_t *)
(27,structCharVoid)
(28,for(j = 0; j < 1; j++)
(29,wchar_t *)
(30,sizeof(charVoid)
(31,*structCharVoid)
(32,void *)
(33,j)
(34,)
(35,structCharVoid)
(36,structCharVoid == NULL)
(37,1)
(38,printWLine((wchar_t *)
(39,j)
(40,SRC_STR)
(41,structCharVoid->charFirst)
(42,structCharVoid)
(43,(void *)
(44,structCharVoid->voidSecond)
(45,j)
(46,* structCharVoid = (charVoid *)
(47,structCharVoid->charFirst)
(48,0)
(49,charVoid *)
(50,j = 0)
(51,charVoid)
(52,structCharVoid)
(53,'\\\\0')
(54,structCharVoid)
(55,wchar_t *)
(56,NULL)
(57,j)
(58,1)
(59,voidSecond)
(60,structCharVoid->voidSecond)
(61,)
(62,wchar_t *)
(63,printWLine((wchar_t *)
(64,j++)
(65,SRC_STR)
(66,(wchar_t *)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^