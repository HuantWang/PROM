-----label-----
1
-----code-----
void CWE122_Heap_Based_Buffer_Overflow__CWE135_34_bad()
{
    void * data;
    CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)dataBadBuffer;
    }
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
9,10
9,11
12,13
13,14
13,15
14,15
16,17
18,19
19,20
19,21
20,21
22,23
24,25
24,26
24,27
24,28
24,29
25,26
26,27
26,28
28,29
28,30
28,31
31,32
32,33
32,34
33,34
33,35
35,36
37,38
37,39
38,39
40,41
40,42
42,43
43,44
43,45
46,47
46,48
47,48
47,49
48,49
50,51
52,53
53,54
54,55
54,56
55,56
57,58
59,60
60,61
60,62
60,63
60,64
61,62
63,64
66,67
66,68
69,70
70,71
70,72
71,72
71,73
72,73
74,75
74,76
78,79
79,80
79,81
80,81
82,83
82,84
83,84
83,85
85,86
87,88
89,90
90,91
90,92
91,92
91,93
92,93
95,96
97,98
97,99
98,99
99,100
99,101
101,102
101,103
101,104
104,105
105,106
105,107
106,107
109,110
109,111
109,112
109,113
109,114
109,115
110,111
111,112
111,113
112,113
114,115
114,116
116,117
117,118
117,119
118,119
120,121
120,122
121,122
121,123
123,124
125,126
127,128
128,129
128,130
130,131
130,132
130,133
133,134
134,135
134,136
135,136
135,137
137,138
139,140
139,141
139,142
140,141
142,143
142,144
143,144
146,147
147,148
147,149
150,151
150,152
151,152
151,153
152,153
154,155
156,157
157,158
158,159
158,160
159,160
161,162
163,164
164,165
164,166
165,166
165,167
168,169
168,170
168,171
169,170
171,172
173,174
175,176
176,177
176,178
177,178
179,180
179,181
180,181
180,182
182,183
184,185
186,187
187,188
187,189
188,189
190,191
-----nextToken-----
2,4,8,10,11,15,17,21,23,27,29,30,34,36,39,41,44,45,49,51,56,58,62,64,65,67,68,73,75,76,77,81,84,86,88,93,94,96,100,102,103,107,108,113,115,119,122,124,126,129,131,132,136,138,141,144,145,148,149,153,155,160,162,166,167,170,172,174,178,181,183,185,189,191
-----computeFrom-----
19,20
19,21
40,41
40,42
47,48
47,49
66,67
66,68
70,71
70,72
74,75
74,76
79,80
79,81
90,91
90,92
142,143
142,144
151,152
151,153
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE122_Heap_Based_Buffer_Overflow__CWE135_34_bad(){    void * data;    CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType myUnion;    data = NULL;    {        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));        if (dataBadBuffer == NULL) {exit(-1);}        wmemset(dataBadBuffer, L'A', 50-1);        dataBadBuffer[50-1] = L'\0';        /* POTENTIAL FLAW: Set data to point to a wide string */        data = (void *)dataBadBuffer;    }    myUnion.unionFirst = data;    {        void * data = myUnion.unionSecond;        {            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */            size_t dataLen = strlen((char *)data);            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));            if (dest == NULL) {exit(-1);}            (void)wcscpy(dest, data);            printLine((char *)dest);            free(dest);        }    }}
void
CWE122_Heap_Based_Buffer_Overflow__CWE135_34_bad()
CWE122_Heap_Based_Buffer_Overflow__CWE135_34_bad
{    void * data;    CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType myUnion;    data = NULL;    {        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));        if (dataBadBuffer == NULL) {exit(-1);}        wmemset(dataBadBuffer, L'A', 50-1);        dataBadBuffer[50-1] = L'\0';        /* POTENTIAL FLAW: Set data to point to a wide string */        data = (void *)dataBadBuffer;    }    myUnion.unionFirst = data;    {        void * data = myUnion.unionSecond;        {            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */            size_t dataLen = strlen((char *)data);            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));            if (dest == NULL) {exit(-1);}            (void)wcscpy(dest, data);            printLine((char *)dest);            free(dest);        }    }}
void * data;
void * data;
void
* data
*
data
CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType
CWE122_Heap_Based_Buffer_Overflow__CWE135_34_unionType
myUnion
myUnion
data = NULL;
data = NULL
data
data
NULL
NULL
{        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));        if (dataBadBuffer == NULL) {exit(-1);}        wmemset(dataBadBuffer, L'A', 50-1);        dataBadBuffer[50-1] = L'\0';        /* POTENTIAL FLAW: Set data to point to a wide string */        data = (void *)dataBadBuffer;    }
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
wchar_t
* dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t))
*
dataBadBuffer
= (wchar_t *)malloc(50*sizeof(wchar_t))
(wchar_t *)malloc(50*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(50*sizeof(wchar_t))
malloc
malloc
50*sizeof(wchar_t)
50
sizeof(wchar_t)
wchar_t
wchar_t

if (dataBadBuffer == NULL) {exit(-1);}
dataBadBuffer == NULL
dataBadBuffer
dataBadBuffer
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wmemset(dataBadBuffer, L'A', 50-1);
wmemset(dataBadBuffer, L'A', 50-1)
wmemset
wmemset
dataBadBuffer
dataBadBuffer
L'A'
50-1
50
1
dataBadBuffer[50-1] = L'\0';
dataBadBuffer[50-1] = L'\0'
dataBadBuffer[50-1]
dataBadBuffer
dataBadBuffer
50-1
50
1
L'\0'
data = (void *)dataBadBuffer;
data = (void *)dataBadBuffer
data
data
(void *)dataBadBuffer
void *
void
*
*
dataBadBuffer
dataBadBuffer
myUnion.unionFirst = data;
myUnion.unionFirst = data
myUnion.unionFirst
myUnion
myUnion
unionFirst
data
data
{        void * data = myUnion.unionSecond;        {            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */            size_t dataLen = strlen((char *)data);            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));            if (dest == NULL) {exit(-1);}            (void)wcscpy(dest, data);            printLine((char *)dest);            free(dest);        }    }
void * data = myUnion.unionSecond;
void * data = myUnion.unionSecond;
void
* data = myUnion.unionSecond
*
data
= myUnion.unionSecond
myUnion.unionSecond
myUnion
myUnion
unionSecond
{            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */            size_t dataLen = strlen((char *)data);            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));            if (dest == NULL) {exit(-1);}            (void)wcscpy(dest, data);            printLine((char *)dest);            free(dest);        }
size_t dataLen = strlen((char *)data);
size_t dataLen = strlen((char *)data);
size_t
size_t
dataLen = strlen((char *)data)
dataLen
= strlen((char *)data)
strlen((char *)data)
strlen
strlen
(char *)data
char *
char
*
*
data
data
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
void
* dest = (void *)calloc(dataLen+1, sizeof(wchar_t))
*
dest
= (void *)calloc(dataLen+1, sizeof(wchar_t))
(void *)calloc(dataLen+1, sizeof(wchar_t))
void *
void
*
*
calloc(dataLen+1, sizeof(wchar_t))
calloc
calloc
dataLen+1
dataLen
dataLen
1
sizeof(wchar_t)
wchar_t
wchar_t

if (dest == NULL) {exit(-1);}
dest == NULL
dest
dest
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
(void)wcscpy(dest, data);
(void)wcscpy(dest, data)
void
void

wcscpy(dest, data)
wcscpy
wcscpy
dest
dest
data
data
printLine((char *)dest);
printLine((char *)dest)
printLine
printLine
(char *)dest
char *
char
*
*
dest
dest
free(dest);
free(dest)
free
free
dest
dest
-----joern-----
(35,77,0)
(26,17,0)
(59,53,0)
(17,30,0)
(45,42,0)
(44,34,0)
(21,36,0)
(41,3,0)
(77,32,0)
(24,77,0)
(1,43,0)
(1,21,0)
(12,13,0)
(28,81,0)
(0,8,0)
(54,29,0)
(65,58,0)
(56,42,0)
(49,28,0)
(28,3,0)
(25,21,0)
(36,50,0)
(29,5,0)
(8,29,0)
(4,48,0)
(27,39,0)
(80,30,0)
(71,21,0)
(77,24,0)
(6,66,0)
(20,66,0)
(48,72,0)
(32,37,0)
(19,42,0)
(23,29,0)
(8,36,0)
(79,24,0)
(51,48,0)
(30,40,0)
(50,36,0)
(22,37,0)
(63,3,0)
(2,44,0)
(60,13,0)
(68,17,0)
(5,72,0)
(58,28,0)
(81,34,0)
(18,14,0)
(13,40,0)
(44,14,0)
(1,33,0)
(77,35,0)
(7,40,0)
(9,78,0)
(21,32,0)
(42,56,0)
(72,48,0)
(52,40,0)
(20,75,0)
(36,21,0)
(47,32,0)
(30,56,0)
(34,81,0)
(33,32,0)
(36,8,0)
(5,32,0)
(62,37,0)
(27,31,0)
(81,28,0)
(73,25,0)
(8,0,0)
(53,21,0)
(70,3,0)
(16,78,0)
(61,81,0)
(42,28,0)
(37,40,0)
(76,1,0)
(33,1,0)
(78,62,0)
(72,5,0)
(24,21,0)
(34,44,0)
(10,32,0)
(48,62,0)
(57,32,0)
(69,5,0)
(14,44,0)
(62,78,0)
(67,58,0)
(64,62,0)
(81,61,0)
(53,32,0)
(42,45,0)
(39,27,0)
(38,0,0)
(46,25,0)
(55,24,0)
(48,51,0)
(11,56,0)
(24,62,0)
(66,20,0)
(43,1,0)
(56,3,0)
(3,40,0)
(15,39,0)
(29,8,0)
(5,72,1)
(58,28,1)
(79,25,1)
(20,66,1)
(42,45,1)
(70,58,1)
(8,0,1)
(29,5,1)
(48,62,1)
(49,13,1)
(36,50,1)
(81,61,1)
(55,79,1)
(64,30,1)
(53,21,1)
(56,42,1)
(44,14,1)
(24,21,1)
(19,11,1)
(13,60,1)
(24,55,1)
(58,67,1)
(71,5,1)
(24,62,1)
(48,4,1)
(11,70,1)
(0,38,1)
(28,81,1)
(25,46,1)
(1,43,1)
(76,77,1)
(14,18,1)
(77,35,1)
(21,36,1)
(73,21,1)
(2,49,1)
(39,15,1)
(48,51,1)
(8,29,1)
(34,44,1)
(67,65,1)
(1,76,1)
(42,19,1)
(30,80,1)
(36,8,1)
(78,16,1)
(77,24,1)
(26,68,1)
(60,12,1)
(69,62,1)
(53,59,1)
(9,64,1)
(18,2,1)
(68,56,1)
(46,73,1)
(1,21,1)
(62,78,1)
(23,54,1)
(15,25,1)
(72,48,1)
(29,23,1)
(17,26,1)
(4,69,1)
(16,9,1)
(33,1,1)
(27,39,1)
(81,34,1)
(38,29,1)
(74,53,1)
(66,6,1)
(70,20,1)
(80,17,1)
(25,21,1)
(30,56,1)
(79,27,1)
(6,58,1)
(42,28,1)
(59,33,1)
(65,28,1)
(54,71,1)
(48,62,2)
(77,24,2)
(8,29,2)
(39,25,2)
(36,8,2)
(8,0,2)
(72,48,2)
(58,28,2)
(20,66,2)
(48,51,2)
(66,58,2)
(44,14,2)
(27,39,2)
(42,28,2)
(1,21,2)
(34,44,2)
(33,1,2)
(42,45,2)
(1,43,2)
(29,5,2)
(62,78,2)
(36,50,2)
(21,36,2)
(77,35,2)
(81,34,2)
(24,21,2)
(20,58,2)
(81,61,2)
(25,21,2)
(5,72,2)
(56,42,2)
(15,25,2)
(28,81,2)
(24,62,2)
(6,58,2)
(53,21,2)
(30,56,2)
(27,25,2)
-----------------------------------
(0,sizeof(wchar_t)
(1,(char *)
(2,50)
(3,)
(4,data)
(5,dataLen = strlen((char *)
(6,1)
(7,myUnion)
(8,calloc(dataLen+1, sizeof(wchar_t)
(9,myUnion)
(10,if (dest == NULL)
(11,data)
(12,data)
(13,data = NULL)
(14,sizeof(wchar_t)
(15,1)
(16,unionSecond)
(17,myUnion.unionFirst)
(18,wchar_t)
(19,dataBadBuffer)
(20,exit(-1)
(21,* dest = (void *)
(22,data)
(23,1)
(24,wcscpy(dest, data)
(25,dest == NULL)
(26,unionFirst)
(27,exit(-1)
(28,* dataBadBuffer = (wchar_t *)
(29,dataLen+1)
(30,myUnion.unionFirst = data)
(31,)
(32,)
(33,printLine((char *)
(34,malloc(50*sizeof(wchar_t)
(35,void)
(36,(void *)
(37,)
(38,wchar_t)
(39,-1)
(40,)
(41,if (dataBadBuffer == NULL)
(42,(void *)
(43,char *)
(44,50*sizeof(wchar_t)
(45,void *)
(46,NULL)
(47,dest)
(48,(char *)
(49,dataBadBuffer)
(50,void *)
(51,char *)
(52,data)
(53,free(dest)
(54,dataLen)
(55,data)
(56,data = (void *)
(57,dataLen)
(58,dataBadBuffer == NULL)
(59,dest)
(60,NULL)
(61,wchar_t *)
(62,* data = myUnion.unionSecond)
(63,dataBadBuffer)
(64,data)
(65,dataBadBuffer)
(66,-1)
(67,NULL)
(68,myUnion)
(69,dataLen)
(70,'\\\\0')
(71,dest)
(72,strlen((char *)
(73,dest)
(74,RET)
(75,)
(76,dest)
(77,(void)
(78,myUnion.unionSecond)
(79,dest)
(80,data)
(81,(wchar_t *)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^