-----label-----
1
-----code-----
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_12_bad()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        /* FIX: Allocate and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
10,12
13,14
14,15
14,16
15,16
17,18
19,20
19,21
19,22
20,21
21,22
23,24
23,25
24,25
25,26
25,27
26,27
28,29
28,30
29,30
29,31
30,31
32,33
34,35
34,36
35,36
37,38
37,39
39,40
40,41
40,42
41,42
44,45
44,46
45,46
45,47
46,47
48,49
50,51
51,52
52,53
52,54
53,54
55,56
57,58
57,59
58,59
59,60
59,61
60,61
62,63
62,64
63,64
63,65
64,65
66,67
68,69
68,70
69,70
71,72
71,73
73,74
74,75
74,76
75,76
78,79
78,80
79,80
79,81
80,81
82,83
84,85
85,86
86,87
86,88
87,88
89,90
91,92
91,93
91,94
92,93
93,94
93,95
94,95
96,97
96,98
98,99
100,101
100,102
101,102
102,103
102,104
103,104
105,106
107,108
107,109
107,110
107,111
108,109
109,110
109,111
110,111
113,114
113,115
114,115
117,118
118,119
120,121
120,122
121,122
122,123
122,124
123,124
123,125
124,125
124,126
125,126
127,128
131,132
132,133
132,134
133,134
133,135
134,135
134,136
135,136
137,138
141,142
141,143
141,144
141,145
142,143
143,144
143,145
144,145
146,147
148,149
148,150
148,151
148,152
149,150
150,151
150,152
151,152
154,155
154,156
155,156
158,159
159,160
161,162
162,163
163,164
163,165
164,165
164,166
165,166
167,168
169,170
169,171
170,171
172,173
174,175
175,176
175,177
176,177
178,179
179,180
179,181
180,181
183,184
184,185
184,186
185,186
187,188
-----nextToken-----
2,4,9,11,12,16,18,22,27,31,33,36,38,42,43,47,49,54,56,61,65,67,70,72,76,77,81,83,88,90,95,97,99,104,106,111,112,115,116,119,126,128,129,130,136,138,139,140,145,147,152,153,156,157,160,166,168,171,173,177,181,182,186,188
-----computeFrom-----
14,15
14,16
25,26
25,27
37,38
37,39
45,46
45,47
59,60
59,61
71,72
71,73
79,80
79,81
109,110
109,111
113,114
113,115
122,123
122,124
132,133
132,134
150,151
150,152
154,155
154,156
163,164
163,165
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_12_bad(){    twoIntsStruct * data;    data = NULL;    if(globalReturnsTrueOrFalse())    {        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }    else    {        /* FIX: Allocate and point data to a large buffer that is at least as large as the large buffer used in the sink */        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }    {        twoIntsStruct source[100];        {            size_t i;            /* Initialize array */            for (i = 0; i < 100; i++)            {                source[i].intOne = 0;                source[i].intTwo = 0;            }        }        {            size_t i;            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */            for (i = 0; i < 100; i++)            {                data[i] = source[i];            }            printStructLine(&data[0]);            free(data);        }    }}
void
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_12_bad()
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_12_bad
{    twoIntsStruct * data;    data = NULL;    if(globalReturnsTrueOrFalse())    {        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }    else    {        /* FIX: Allocate and point data to a large buffer that is at least as large as the large buffer used in the sink */        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }    {        twoIntsStruct source[100];        {            size_t i;            /* Initialize array */            for (i = 0; i < 100; i++)            {                source[i].intOne = 0;                source[i].intTwo = 0;            }        }        {            size_t i;            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */            for (i = 0; i < 100; i++)            {                data[i] = source[i];            }            printStructLine(&data[0]);            free(data);        }    }}
twoIntsStruct * data;
twoIntsStruct * data;
twoIntsStruct
twoIntsStruct
* data
*
data
data = NULL;
data = NULL
data
data
NULL
NULL
if(globalReturnsTrueOrFalse())    {        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }    else    {        /* FIX: Allocate and point data to a large buffer that is at least as large as the large buffer used in the sink */        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct))
data
data
(twoIntsStruct *)malloc(50*sizeof(twoIntsStruct))
twoIntsStruct *
twoIntsStruct
twoIntsStruct
*
*
malloc(50*sizeof(twoIntsStruct))
malloc
malloc
50*sizeof(twoIntsStruct)
50
sizeof(twoIntsStruct)
twoIntsStruct
twoIntsStruct
twoIntsStruct

if (data == NULL) {exit(-1);}
data == NULL
data
data
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
{        /* FIX: Allocate and point data to a large buffer that is at least as large as the large buffer used in the sink */        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));        if (data == NULL) {exit(-1);}    }
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct))
data
data
(twoIntsStruct *)malloc(100*sizeof(twoIntsStruct))
twoIntsStruct *
twoIntsStruct
twoIntsStruct
*
*
malloc(100*sizeof(twoIntsStruct))
malloc
malloc
100*sizeof(twoIntsStruct)
100
sizeof(twoIntsStruct)
twoIntsStruct
twoIntsStruct
twoIntsStruct

if (data == NULL) {exit(-1);}
data == NULL
data
data
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
{        twoIntsStruct source[100];        {            size_t i;            /* Initialize array */            for (i = 0; i < 100; i++)            {                source[i].intOne = 0;                source[i].intTwo = 0;            }        }        {            size_t i;            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */            for (i = 0; i < 100; i++)            {                data[i] = source[i];            }            printStructLine(&data[0]);            free(data);        }    }
twoIntsStruct source[100];
twoIntsStruct source[100];
twoIntsStruct
twoIntsStruct
source[100]
source
[100]
100
{            size_t i;            /* Initialize array */            for (i = 0; i < 100; i++)            {                source[i].intOne = 0;                source[i].intTwo = 0;            }        }
size_t i;
size_t i;
size_t
size_t
i
i
for (i = 0; i < 100; i++)            {                source[i].intOne = 0;                source[i].intTwo = 0;            }
i = 0;
i = 0
i
i
0
i < 100
i
i
100
i++
i
i
{                source[i].intOne = 0;                source[i].intTwo = 0;            }
source[i].intOne = 0;
source[i].intOne = 0
source[i].intOne
source[i]
source
source
i
i
intOne
0
source[i].intTwo = 0;
source[i].intTwo = 0
source[i].intTwo
source[i]
source
source
i
i
intTwo
0
{            size_t i;            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */            for (i = 0; i < 100; i++)            {                data[i] = source[i];            }            printStructLine(&data[0]);            free(data);        }
size_t i;
size_t i;
size_t
size_t
i
i
for (i = 0; i < 100; i++)            {                data[i] = source[i];            }
i = 0;
i = 0
i
i
0
i < 100
i
i
100
i++
i
i
{                data[i] = source[i];            }
data[i] = source[i];
data[i] = source[i]
data[i]
data
data
i
i
source[i]
source
source
i
i
printStructLine(&data[0]);
printStructLine(&data[0])
printStructLine
printStructLine
&data[0]
data[0]
data
data
0
free(data);
free(data)
free
free
data
data
-----joern-----
(33,75,0)
(82,92,0)
(42,11,0)
(30,12,0)
(71,29,0)
(0,3,0)
(28,89,0)
(49,7,0)
(40,81,0)
(34,9,0)
(29,89,0)
(17,31,0)
(95,87,0)
(84,9,0)
(69,20,0)
(83,9,0)
(52,73,0)
(58,43,0)
(7,5,0)
(4,29,0)
(73,5,0)
(10,96,0)
(61,5,0)
(28,97,0)
(35,9,0)
(21,52,0)
(80,87,0)
(62,7,0)
(36,29,0)
(20,89,0)
(4,66,0)
(84,60,0)
(14,43,0)
(50,8,0)
(27,18,0)
(65,77,0)
(44,18,0)
(48,26,0)
(27,0,0)
(82,89,0)
(15,32,0)
(24,32,0)
(74,84,0)
(92,57,0)
(18,44,0)
(2,18,0)
(23,89,0)
(64,57,0)
(43,12,0)
(29,4,0)
(0,27,0)
(90,78,0)
(81,8,0)
(76,60,0)
(16,44,0)
(18,27,0)
(26,73,0)
(25,26,0)
(70,64,0)
(22,30,0)
(55,20,0)
(95,47,0)
(75,44,0)
(28,44,0)
(92,82,0)
(18,2,0)
(66,26,0)
(67,5,0)
(1,75,0)
(29,44,0)
(57,92,0)
(38,28,0)
(19,73,0)
(45,52,0)
(96,44,0)
(97,81,0)
(6,14,0)
(32,8,0)
(79,82,0)
(31,8,0)
(91,28,0)
(81,97,0)
(96,89,0)
(77,65,0)
(34,14,0)
(28,8,0)
(65,93,0)
(56,0,0)
(57,64,0)
(60,30,0)
(59,34,0)
(94,77,0)
(3,0,0)
(60,84,0)
(46,84,0)
(54,3,0)
(68,57,0)
(78,9,0)
(41,8,0)
(14,34,0)
(82,79,0)
(44,11,0)
(13,9,0)
(72,37,0)
(88,81,0)
(87,95,0)
(96,26,0)
(66,4,0)
(85,78,0)
(89,82,0)
(53,83,0)
(97,39,0)
(89,37,0)
(86,34,0)
(30,22,1)
(81,8,1)
(56,16,1)
(78,9,1)
(27,0,1)
(44,18,1)
(28,89,1)
(40,28,1)
(35,20,1)
(3,54,1)
(41,50,1)
(35,75,1)
(31,17,1)
(29,89,1)
(68,23,1)
(96,89,1)
(9,13,1)
(85,9,1)
(71,32,1)
(75,1,1)
(18,27,1)
(53,30,1)
(60,84,1)
(82,92,1)
(58,14,1)
(1,33,1)
(18,2,1)
(66,4,1)
(4,29,1)
(62,49,1)
(85,83,1)
(15,24,1)
(70,68,1)
(46,43,1)
(74,46,1)
(87,80,1)
(97,81,1)
(84,9,1)
(86,59,1)
(43,58,1)
(94,75,1)
(32,8,1)
(95,87,1)
(69,89,1)
(32,15,1)
(28,91,1)
(7,62,1)
(23,63,1)
(64,70,1)
(96,10,1)
(55,69,1)
(35,65,1)
(84,74,1)
(36,71,1)
(34,9,1)
(35,95,1)
(8,41,1)
(83,9,1)
(59,78,1)
(0,3,1)
(89,82,1)
(24,8,1)
(22,60,1)
(24,31,1)
(77,94,1)
(96,44,1)
(65,77,1)
(90,85,1)
(16,63,1)
(54,56,1)
(28,44,1)
(82,79,1)
(14,34,1)
(63,7,1)
(75,44,1)
(29,36,1)
(78,90,1)
(13,35,1)
(20,89,1)
(29,44,1)
(51,96,1)
(80,20,1)
(10,66,1)
(91,38,1)
(57,64,1)
(60,76,1)
(88,40,1)
(28,8,1)
(20,55,1)
(38,32,1)
(17,97,1)
(83,53,1)
(50,78,1)
(81,88,1)
(31,8,1)
(33,44,1)
(14,6,1)
(92,57,1)
(34,86,1)
(6,34,1)
(76,84,1)
(60,78,2)
(83,78,2)
(55,63,2)
(60,84,2)
(24,32,2)
(90,78,2)
(89,82,2)
(68,63,2)
(97,81,2)
(81,8,2)
(16,63,2)
(70,63,2)
(65,77,2)
(0,3,2)
(80,20,2)
(3,63,2)
(65,75,2)
(15,32,2)
(34,78,2)
(96,44,2)
(64,63,2)
(78,9,2)
(69,63,2)
(31,8,2)
(38,32,2)
(95,20,2)
(84,78,2)
(28,44,2)
(34,9,2)
(1,63,2)
(77,75,2)
(88,32,2)
(84,9,2)
(92,57,2)
(82,92,2)
(4,29,2)
(94,75,2)
(97,32,2)
(92,63,2)
(57,64,2)
(33,63,2)
(23,63,2)
(0,63,2)
(18,63,2)
(30,78,2)
(58,78,2)
(17,32,2)
(85,78,2)
(82,79,2)
(66,4,2)
(28,32,2)
(22,78,2)
(28,89,2)
(27,0,2)
(43,78,2)
(53,78,2)
(31,32,2)
(83,9,2)
(56,63,2)
(96,89,2)
(44,18,2)
(76,78,2)
(46,78,2)
(78,78,2)
(20,63,2)
(91,32,2)
(40,32,2)
(87,20,2)
(75,63,2)
(29,44,2)
(29,89,2)
(44,63,2)
(95,87,2)
(14,34,2)
(14,78,2)
(86,78,2)
(20,89,2)
(32,32,2)
(82,63,2)
(89,63,2)
(18,2,2)
(74,78,2)
(18,27,2)
(54,63,2)
(59,78,2)
(28,8,2)
(27,63,2)
(57,63,2)
(75,44,2)
(81,32,2)
(6,78,2)
(32,8,2)
-----------------------------------
(0,50*sizeof(twoIntsStruct)
(1,NULL)
(2,twoIntsStruct *)
(3,sizeof(twoIntsStruct)
(4,&data[0])
(5,)
(6,intOne)
(7,data = NULL)
(8,i = 0)
(9,i = 0)
(10,data)
(11,)
(12,)
(13,0)
(14,source[i].intOne)
(15,100)
(16,data)
(17,i)
(18,(twoIntsStruct *)
(19,source)
(20,data == NULL)
(21,for (i = 0; i < 100; i++)
(22,0)
(23,data)
(24,i)
(25,i)
(26,)
(27,malloc(50*sizeof(twoIntsStruct)
(28,data[i])
(29,data[0])
(30,source[i].intTwo = 0)
(31,i++)
(32,i < 100)
(33,data)
(34,source[i])
(35,i)
(36,0)
(37,)
(38,data)
(39,)
(40,source)
(41,0)
(42,if (data == NULL)
(43,source[i].intOne = 0)
(44,data = (twoIntsStruct *)
(45,i)
(46,source)
(47,)
(48,for (i = 0; i < 100; i++)
(49,data)
(50,i)
(51,RET)
(52,)
(53,i)
(54,twoIntsStruct)
(55,NULL)
(56,50)
(57,100*sizeof(twoIntsStruct)
(58,0)
(59,source)
(60,source[i].intTwo)
(61,data)
(62,NULL)
(63,globalReturnsTrueOrFalse()
(64,sizeof(twoIntsStruct)
(65,exit(-1)
(66,printStructLine(&data[0])
(67,if(globalReturnsTrueOrFalse()
(68,100)
(69,data)
(70,twoIntsStruct)
(71,data)
(72,if (data == NULL)
(73,)
(74,i)
(75,data == NULL)
(76,intTwo)
(77,-1)
(78,i < 100)
(79,twoIntsStruct *)
(80,1)
(81,source[i])
(82,(twoIntsStruct *)
(83,i++)
(84,source[i])
(85,i)
(86,i)
(87,-1)
(88,i)
(89,data = (twoIntsStruct *)
(90,100)
(91,i)
(92,malloc(100*sizeof(twoIntsStruct)
(93,)
(94,1)
(95,exit(-1)
(96,free(data)
(97,data[i] = source[i])
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^