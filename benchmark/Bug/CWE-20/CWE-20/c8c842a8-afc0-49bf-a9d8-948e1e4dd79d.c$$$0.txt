-----label-----
1
-----code-----
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_32_bad()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FLAW: Did not leave space for a null terminator */
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = strlen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printLine(data);
            free(data);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
9,10
9,11
12,13
13,14
13,15
15,16
15,17
15,18
15,19
19,20
20,21
21,22
23,24
24,25
24,26
26,27
26,28
26,29
26,30
30,31
31,32
32,33
34,35
35,36
35,37
36,37
38,39
40,41
40,42
40,43
40,44
41,42
42,43
42,44
44,45
44,46
44,47
47,48
48,49
49,50
51,52
52,53
52,54
53,54
55,56
55,57
56,57
56,58
58,59
60,61
60,62
61,62
63,64
63,65
65,66
66,67
66,68
69,70
69,71
70,71
70,72
71,72
73,74
75,76
76,77
77,78
77,79
78,79
80,81
82,83
83,84
83,85
84,85
85,86
87,88
89,90
89,91
90,91
91,92
91,93
93,94
93,95
93,96
96,97
97,98
98,99
100,101
100,102
100,103
100,104
100,105
100,106
101,102
102,103
102,104
104,105
104,106
104,107
106,107
107,108
107,109
110,111
111,112
113,114
114,115
114,116
114,117
115,116
117,118
119,120
121,122
122,123
122,124
123,124
125,126
125,127
126,127
128,129
130,131
130,132
130,133
130,134
131,132
132,133
132,134
133,134
136,137
136,138
137,138
139,140
139,141
140,141
143,144
144,145
146,147
147,148
148,149
148,150
149,150
149,151
150,151
152,153
154,155
154,156
155,156
157,158
159,160
160,161
160,162
161,162
163,164
165,166
166,167
166,168
167,168
169,170
-----nextToken-----
2,4,8,10,11,14,16,17,18,22,25,27,28,29,33,37,39,43,45,46,50,54,57,59,62,64,67,68,72,74,79,81,86,88,92,94,95,99,103,105,108,109,112,116,118,120,124,127,129,134,135,138,141,142,145,151,153,156,158,162,164,168,170
-----computeFrom-----
35,36
35,37
52,53
52,54
63,64
63,65
70,71
70,72
83,84
83,85
107,108
107,109
122,123
122,124
132,133
132,134
136,137
136,138
139,140
139,141
148,149
148,150
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;BinaryExpression;LiteralExpression;LiteralExpression;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_32_bad(){    char * data;    char * *dataPtr1 = &data;    char * *dataPtr2 = &data;    data = NULL;    {        char * data = *dataPtr1;        /* FLAW: Did not leave space for a null terminator */        data = (char *)malloc(10*sizeof(char));        if (data == NULL) {exit(-1);}        *dataPtr1 = data;    }    {        char * data = *dataPtr2;        {            char source[10+1] = SRC_STRING;            size_t i, sourceLen;            sourceLen = strlen(source);            /* Copy length + 1 to include NUL terminator from source */            /* POTENTIAL FLAW: data may not have enough space to hold source */            for (i = 0; i < sourceLen + 1; i++)            {                data[i] = source[i];            }            printLine(data);            free(data);        }    }}
void
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_32_bad()
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_32_bad
{    char * data;    char * *dataPtr1 = &data;    char * *dataPtr2 = &data;    data = NULL;    {        char * data = *dataPtr1;        /* FLAW: Did not leave space for a null terminator */        data = (char *)malloc(10*sizeof(char));        if (data == NULL) {exit(-1);}        *dataPtr1 = data;    }    {        char * data = *dataPtr2;        {            char source[10+1] = SRC_STRING;            size_t i, sourceLen;            sourceLen = strlen(source);            /* Copy length + 1 to include NUL terminator from source */            /* POTENTIAL FLAW: data may not have enough space to hold source */            for (i = 0; i < sourceLen + 1; i++)            {                data[i] = source[i];            }            printLine(data);            free(data);        }    }}
char * data;
char * data;
char
* data
*
data
char * *dataPtr1 = &data;
char * *dataPtr1 = &data;
char
* *dataPtr1 = &data
*
*
dataPtr1
= &data
&data
data
data
char * *dataPtr2 = &data;
char * *dataPtr2 = &data;
char
* *dataPtr2 = &data
*
*
dataPtr2
= &data
&data
data
data
data = NULL;
data = NULL
data
data
NULL
NULL
{        char * data = *dataPtr1;        /* FLAW: Did not leave space for a null terminator */        data = (char *)malloc(10*sizeof(char));        if (data == NULL) {exit(-1);}        *dataPtr1 = data;    }
char * data = *dataPtr1;
char * data = *dataPtr1;
char
* data = *dataPtr1
*
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
data = (char *)malloc(10*sizeof(char));
data = (char *)malloc(10*sizeof(char))
data
data
(char *)malloc(10*sizeof(char))
char *
char
*
*
malloc(10*sizeof(char))
malloc
malloc
10*sizeof(char)
10
sizeof(char)
char
char

if (data == NULL) {exit(-1);}
data == NULL
data
data
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        char * data = *dataPtr2;        {            char source[10+1] = SRC_STRING;            size_t i, sourceLen;            sourceLen = strlen(source);            /* Copy length + 1 to include NUL terminator from source */            /* POTENTIAL FLAW: data may not have enough space to hold source */            for (i = 0; i < sourceLen + 1; i++)            {                data[i] = source[i];            }            printLine(data);            free(data);        }    }
char * data = *dataPtr2;
char * data = *dataPtr2;
char
* data = *dataPtr2
*
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
{            char source[10+1] = SRC_STRING;            size_t i, sourceLen;            sourceLen = strlen(source);            /* Copy length + 1 to include NUL terminator from source */            /* POTENTIAL FLAW: data may not have enough space to hold source */            for (i = 0; i < sourceLen + 1; i++)            {                data[i] = source[i];            }            printLine(data);            free(data);        }
char source[10+1] = SRC_STRING;
char source[10+1] = SRC_STRING;
char
source[10+1] = SRC_STRING
source
[10+1]
10+1
10
1
= SRC_STRING
SRC_STRING
SRC_STRING
size_t i, sourceLen;
size_t i, sourceLen;
size_t
size_t
i
i
sourceLen
sourceLen
sourceLen = strlen(source);
sourceLen = strlen(source)
sourceLen
sourceLen
strlen(source)
strlen
strlen
source
source
for (i = 0; i < sourceLen + 1; i++)            {                data[i] = source[i];            }
i = 0;
i = 0
i
i
0
i < sourceLen + 1
i
i
sourceLen + 1
sourceLen
sourceLen
1
i++
i
i
{                data[i] = source[i];            }
data[i] = source[i];
data[i] = source[i]
data[i]
data
data
i
i
source[i]
source
source
i
i
printLine(data);
printLine(data)
printLine
printLine
data
data
free(data);
free(data)
free
free
data
data
-----joern-----
(29,17,0)
(18,3,0)
(30,3,0)
(33,66,0)
(40,36,0)
(40,72,0)
(72,40,0)
(64,74,0)
(49,37,0)
(82,19,0)
(23,21,0)
(81,4,0)
(15,42,0)
(75,52,0)
(34,7,0)
(53,54,0)
(57,37,0)
(61,5,0)
(66,13,0)
(9,5,0)
(9,19,0)
(21,23,0)
(41,24,0)
(22,26,0)
(27,50,0)
(8,76,0)
(70,28,0)
(50,76,0)
(12,41,0)
(1,74,0)
(25,37,0)
(42,19,0)
(28,74,0)
(80,50,0)
(74,50,0)
(32,28,0)
(58,24,0)
(6,55,0)
(43,5,0)
(11,30,0)
(46,36,0)
(27,26,0)
(56,21,0)
(10,6,0)
(30,13,0)
(5,27,0)
(38,29,0)
(36,37,0)
(29,23,0)
(26,74,0)
(51,50,0)
(41,49,0)
(45,40,0)
(39,37,0)
(26,27,0)
(13,30,0)
(16,81,0)
(79,72,0)
(59,9,0)
(20,49,0)
(28,17,0)
(21,81,0)
(36,52,0)
(78,63,0)
(31,36,0)
(44,57,0)
(81,37,0)
(47,50,0)
(28,19,0)
(17,73,0)
(31,41,0)
(24,49,0)
(63,23,0)
(4,81,0)
(60,57,0)
(62,7,0)
(71,23,0)
(48,49,0)
(13,66,0)
(68,37,0)
(65,29,0)
(23,76,0)
(55,0,0)
(69,27,0)
(3,30,0)
(66,24,0)
(2,50,0)
(17,28,0)
(55,6,0)
(5,9,0)
(54,50,0)
(76,37,0)
(52,36,0)
(24,66,0)
(54,23,0)
(67,19,0)
(7,24,0)
(77,31,0)
(63,50,0)
(14,4,0)
(72,49,0)
(66,33,0)
(29,19,0)
(4,14,1)
(78,54,1)
(66,33,1)
(59,42,1)
(74,64,1)
(58,72,1)
(1,23,1)
(44,81,1)
(9,5,1)
(45,79,1)
(41,24,1)
(31,36,1)
(17,28,1)
(34,62,1)
(65,38,1)
(66,13,1)
(67,27,1)
(57,60,1)
(54,53,1)
(5,27,1)
(26,22,1)
(40,45,1)
(7,34,1)
(82,67,1)
(10,7,1)
(40,36,1)
(77,7,1)
(43,61,1)
(13,30,1)
(28,19,1)
(81,4,1)
(59,19,1)
(23,21,1)
(71,41,1)
(42,19,1)
(21,81,1)
(54,23,1)
(16,36,1)
(29,65,1)
(30,3,1)
(27,26,1)
(42,15,1)
(63,78,1)
(79,57,1)
(56,71,1)
(61,59,1)
(60,44,1)
(19,82,1)
(5,43,1)
(36,52,1)
(3,18,1)
(6,10,1)
(62,24,1)
(24,66,1)
(32,29,1)
(41,12,1)
(72,40,1)
(75,46,1)
(53,9,1)
(28,70,1)
(55,6,1)
(29,19,1)
(28,74,1)
(52,75,1)
(64,1,1)
(31,77,1)
(21,56,1)
(7,24,1)
(11,58,1)
(14,16,1)
(15,17,1)
(77,55,1)
(35,63,1)
(63,23,1)
(70,32,1)
(18,11,1)
(29,23,1)
(26,74,1)
(22,69,1)
(9,19,1)
(12,31,1)
(69,74,1)
(38,9,1)
(72,40,2)
(43,9,2)
(24,66,2)
(40,36,2)
(27,26,2)
(30,3,2)
(29,19,2)
(41,24,2)
(81,4,2)
(65,9,2)
(38,9,2)
(17,9,2)
(61,9,2)
(70,9,2)
(28,19,2)
(66,13,2)
(66,33,2)
(15,9,2)
(29,9,2)
(17,28,2)
(5,9,2)
(54,23,2)
(42,19,2)
(9,5,2)
(59,9,2)
(10,7,2)
(55,7,2)
(21,81,2)
(63,23,2)
(28,74,2)
(9,19,2)
(32,9,2)
(26,74,2)
(23,21,2)
(29,23,2)
(55,6,2)
(7,24,2)
(42,9,2)
(6,7,2)
(13,30,2)
(36,52,2)
(9,9,2)
(31,36,2)
(5,27,2)
(28,9,2)
-----------------------------------
(0,)
(1,source)
(2,i)
(3,sizeof(char)
(4,&data)
(5,sourceLen + 1)
(6,-1)
(7,data == NULL)
(8,data)
(9,i < sourceLen + 1)
(10,1)
(11,10)
(12,data)
(13,malloc(10*sizeof(char)
(14,data)
(15,i)
(16,dataPtr2)
(17,data[i] = source[i])
(18,char)
(19,i = 0)
(20,if (data == NULL)
(21,*dataPtr2)
(22,source)
(23,* data = *dataPtr2)
(24,data = (char *)
(25,dataPtr2)
(26,strlen(source)
(27,sourceLen = strlen(source)
(28,source[i])
(29,data[i])
(30,10*sizeof(char)
(31,*dataPtr1)
(32,source)
(33,char *)
(34,NULL)
(35,RET)
(36,* *dataPtr1 = &data)
(37,)
(38,data)
(39,data)
(40,*dataPtr1)
(41,*dataPtr1 = data)
(42,i++)
(43,1)
(44,data)
(45,dataPtr1)
(46,dataPtr1)
(47,source)
(48,data)
(49,)
(50,)
(51,sourceLen)
(52,&data)
(53,data)
(54,printLine(data)
(55,exit(-1)
(56,dataPtr2)
(57,data = NULL)
(58,data)
(59,i)
(60,NULL)
(61,sourceLen)
(62,data)
(63,free(data)
(64,SRC_STRING)
(65,i)
(66,(char *)
(67,i)
(68,dataPtr1)
(69,sourceLen)
(70,i)
(71,data)
(72,* data = *dataPtr1)
(73,)
(74,source[10+1] = SRC_STRING)
(75,data)
(76,)
(77,dataPtr1)
(78,data)
(79,data)
(80,for (i = 0; i < sourceLen + 1; i++)
(81,* *dataPtr2 = &data)
(82,0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^