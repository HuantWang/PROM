-----label-----
1
-----code-----
void CWE416_Use_After_Free__malloc_free_int_12_bad()
{
    int * data;
    /* Initialize data */
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */
        free(data);
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        /* FIX: Do not free data in the source */
    }
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Use of data that may have been freed */
        printIntLine(data[0]);
        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */
    }
    else
    {
        /* FIX: Don't use data that may have been freed already */
        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */
        /* do nothing */
        ; /* empty statement needed for some flow variants */
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
9,10
9,11
12,13
13,14
13,15
14,15
16,17
18,19
18,20
18,21
19,20
20,21
22,23
22,24
22,25
22,26
23,24
24,25
24,26
25,26
27,28
27,29
28,29
28,30
30,31
32,33
32,34
33,34
35,36
35,37
37,38
38,39
38,40
41,42
41,43
42,43
42,44
43,44
45,46
47,48
48,49
49,50
49,51
50,51
52,53
54,55
54,56
55,56
56,57
56,58
57,58
59,60
61,62
61,63
61,64
61,65
62,63
63,64
63,65
64,65
67,68
67,69
68,69
71,72
72,73
74,75
75,76
76,77
76,78
77,78
77,79
78,79
80,81
83,84
84,85
84,86
85,86
87,88
89,90
89,91
89,92
90,91
91,92
91,93
92,93
94,95
94,96
95,96
95,97
97,98
99,100
99,101
100,101
102,103
102,104
104,105
105,106
105,107
108,109
108,110
109,110
109,111
110,111
112,113
114,115
115,116
116,117
116,118
117,118
119,120
121,122
121,123
122,123
123,124
123,125
124,125
126,127
128,129
128,130
128,131
128,132
129,130
130,131
130,132
131,132
134,135
134,136
135,136
138,139
139,140
141,142
142,143
143,144
143,145
144,145
144,146
145,146
147,148
150,151
150,152
150,153
151,152
152,153
154,155
155,156
156,157
156,158
157,158
159,160
159,161
160,161
163,164
-----nextToken-----
2,4,8,10,11,15,17,21,26,29,31,34,36,39,40,44,46,51,53,58,60,65,66,69,70,73,79,81,82,86,88,93,96,98,101,103,106,107,111,113,118,120,125,127,132,133,136,137,140,146,148,149,153,158,161,162,164
-----computeFrom-----
13,14
13,15
24,25
24,26
35,36
35,37
42,43
42,44
63,64
63,65
67,68
67,69
76,77
76,78
91,92
91,93
102,103
102,104
109,110
109,111
130,131
130,132
134,135
134,136
143,144
143,145
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;LiteralExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;NullStatement;
-----ast_node-----
void CWE416_Use_After_Free__malloc_free_int_12_bad(){    int * data;    /* Initialize data */    data = NULL;    if(globalReturnsTrueOrFalse())    {        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */        free(data);    }    else    {        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* FIX: Do not free data in the source */    }    if(globalReturnsTrueOrFalse())    {        /* POTENTIAL FLAW: Use of data that may have been freed */        printIntLine(data[0]);        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */    }    else    {        /* FIX: Don't use data that may have been freed already */        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */        /* do nothing */        ; /* empty statement needed for some flow variants */    }}
void
CWE416_Use_After_Free__malloc_free_int_12_bad()
CWE416_Use_After_Free__malloc_free_int_12_bad
{    int * data;    /* Initialize data */    data = NULL;    if(globalReturnsTrueOrFalse())    {        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */        free(data);    }    else    {        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* FIX: Do not free data in the source */    }    if(globalReturnsTrueOrFalse())    {        /* POTENTIAL FLAW: Use of data that may have been freed */        printIntLine(data[0]);        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */    }    else    {        /* FIX: Don't use data that may have been freed already */        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */        /* do nothing */        ; /* empty statement needed for some flow variants */    }}
int * data;
int * data;
int
* data
*
data
data = NULL;
data = NULL
data
data
NULL
NULL
if(globalReturnsTrueOrFalse())    {        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */        free(data);    }    else    {        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* FIX: Do not free data in the source */    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */        free(data);    }
data = (int *)malloc(100*sizeof(int));
data = (int *)malloc(100*sizeof(int))
data
data
(int *)malloc(100*sizeof(int))
int *
int
*
*
malloc(100*sizeof(int))
malloc
malloc
100*sizeof(int)
100
sizeof(int)
int
int

if (data == NULL) {exit(-1);}
data == NULL
data
data
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
{            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }
size_t i;
size_t i;
size_t
size_t
i
i
for(i = 0; i < 100; i++)            {                data[i] = 5;            }
i = 0;
i = 0
i
i
0
i < 100
i
i
100
i++
i
i
{                data[i] = 5;            }
data[i] = 5;
data[i] = 5
data[i]
data
data
i
i
5
free(data);
free(data)
free
free
data
data
{        data = (int *)malloc(100*sizeof(int));        if (data == NULL) {exit(-1);}        {            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }        /* FIX: Do not free data in the source */    }
data = (int *)malloc(100*sizeof(int));
data = (int *)malloc(100*sizeof(int))
data
data
(int *)malloc(100*sizeof(int))
int *
int
*
*
malloc(100*sizeof(int))
malloc
malloc
100*sizeof(int)
100
sizeof(int)
int
int

if (data == NULL) {exit(-1);}
data == NULL
data
data
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
{            size_t i;            for(i = 0; i < 100; i++)            {                data[i] = 5;            }        }
size_t i;
size_t i;
size_t
size_t
i
i
for(i = 0; i < 100; i++)            {                data[i] = 5;            }
i = 0;
i = 0
i
i
0
i < 100
i
i
100
i++
i
i
{                data[i] = 5;            }
data[i] = 5;
data[i] = 5
data[i]
data
data
i
i
5
if(globalReturnsTrueOrFalse())    {        /* POTENTIAL FLAW: Use of data that may have been freed */        printIntLine(data[0]);        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */    }    else    {        /* FIX: Don't use data that may have been freed already */        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */        /* do nothing */        ; /* empty statement needed for some flow variants */    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        /* POTENTIAL FLAW: Use of data that may have been freed */        printIntLine(data[0]);        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */    }
printIntLine(data[0]);
printIntLine(data[0])
printIntLine
printIntLine
data[0]
data
data
0
{        /* FIX: Don't use data that may have been freed already */        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */        /* do nothing */        ; /* empty statement needed for some flow variants */    }
;
-----joern-----
(43,77,0)
(48,43,0)
(82,9,0)
(64,68,0)
(75,51,0)
(82,55,0)
(35,37,0)
(33,67,0)
(82,1,0)
(80,49,0)
(19,30,0)
(62,18,0)
(6,5,0)
(12,84,0)
(13,0,0)
(22,41,0)
(60,77,0)
(8,65,0)
(26,51,0)
(81,34,0)
(69,49,0)
(51,26,0)
(42,20,0)
(67,45,0)
(63,59,0)
(79,30,0)
(17,44,0)
(84,37,0)
(45,34,0)
(47,19,0)
(48,20,0)
(55,82,0)
(2,8,0)
(43,48,0)
(52,9,0)
(53,5,0)
(38,41,0)
(77,60,0)
(20,48,0)
(25,30,0)
(85,67,0)
(56,54,0)
(68,45,0)
(9,37,0)
(57,76,0)
(0,9,0)
(52,37,0)
(5,45,0)
(67,8,0)
(18,30,0)
(36,28,0)
(70,48,0)
(76,14,0)
(23,18,0)
(18,9,0)
(74,72,0)
(66,0,0)
(39,59,0)
(56,5,0)
(5,56,0)
(16,46,0)
(32,30,0)
(78,9,0)
(21,32,0)
(1,82,0)
(86,24,0)
(73,59,0)
(77,43,0)
(41,34,0)
(3,45,0)
(55,51,0)
(9,82,0)
(50,52,0)
(29,26,0)
(40,46,0)
(44,49,0)
(5,9,0)
(27,44,0)
(18,76,0)
(72,59,0)
(71,19,0)
(31,63,0)
(24,36,0)
(77,45,0)
(10,49,0)
(45,77,0)
(46,40,0)
(67,59,0)
(51,55,0)
(36,24,0)
(40,11,0)
(83,68,0)
(7,63,0)
(61,84,0)
(45,77,1)
(24,86,1)
(56,5,1)
(58,63,1)
(3,4,1)
(48,20,1)
(58,52,1)
(39,73,1)
(20,42,1)
(59,39,1)
(68,64,1)
(7,72,1)
(21,76,1)
(74,8,1)
(72,74,1)
(7,59,1)
(67,45,1)
(70,3,1)
(68,45,1)
(66,9,1)
(0,13,1)
(15,58,1)
(29,75,1)
(73,40,1)
(13,66,1)
(85,63,1)
(33,85,1)
(19,30,1)
(72,59,1)
(5,45,1)
(18,62,1)
(18,30,1)
(62,23,1)
(31,7,1)
(36,24,1)
(44,17,1)
(4,44,1)
(75,78,1)
(43,48,1)
(55,51,1)
(46,16,1)
(23,19,1)
(51,26,1)
(83,45,1)
(9,82,1)
(40,46,1)
(57,18,1)
(6,53,1)
(82,55,1)
(79,36,1)
(47,32,1)
(86,0,1)
(50,19,1)
(18,9,1)
(2,67,1)
(77,60,1)
(63,31,1)
(5,9,1)
(76,57,1)
(32,30,1)
(15,56,1)
(32,21,1)
(30,25,1)
(78,4,1)
(52,9,1)
(67,33,1)
(25,79,1)
(53,58,1)
(5,6,1)
(67,59,1)
(82,1,1)
(16,68,1)
(42,70,1)
(47,30,1)
(52,50,1)
(19,71,1)
(71,47,1)
(8,2,1)
(79,0,1)
(63,59,1)
(17,27,1)
(26,29,1)
(0,9,1)
(77,43,1)
(73,68,1)
(64,83,1)
(43,48,2)
(63,4,2)
(13,4,2)
(19,4,2)
(9,4,2)
(68,45,2)
(36,0,2)
(18,30,2)
(67,63,2)
(23,19,2)
(43,4,2)
(32,30,2)
(47,19,2)
(26,4,2)
(82,1,2)
(71,19,2)
(75,4,2)
(48,20,2)
(51,4,2)
(25,4,2)
(5,9,2)
(67,59,2)
(72,63,2)
(46,68,2)
(68,4,2)
(47,4,2)
(5,45,2)
(73,4,2)
(77,43,2)
(7,4,2)
(6,58,2)
(55,51,2)
(55,4,2)
(79,4,2)
(52,4,2)
(82,55,2)
(32,19,2)
(77,4,2)
(82,4,2)
(74,63,2)
(5,58,2)
(21,19,2)
(0,4,2)
(19,30,2)
(36,24,2)
(40,46,2)
(50,4,2)
(31,63,2)
(0,9,2)
(72,59,2)
(19,19,2)
(45,77,2)
(18,9,2)
(67,45,2)
(33,63,2)
(85,63,2)
(70,4,2)
(3,4,2)
(7,63,2)
(83,4,2)
(77,60,2)
(78,4,2)
(39,4,2)
(63,63,2)
(8,63,2)
(56,58,2)
(64,4,2)
(16,68,2)
(24,0,2)
(71,4,2)
(76,19,2)
(53,58,2)
(62,19,2)
(29,4,2)
(48,4,2)
(30,4,2)
(42,4,2)
(66,4,2)
(2,63,2)
(31,4,2)
(9,82,2)
(51,26,2)
(59,4,2)
(20,4,2)
(18,19,2)
(40,68,2)
(86,0,2)
(63,59,2)
(56,5,2)
(57,19,2)
(45,4,2)
(52,9,2)
-----------------------------------
(0,data == NULL)
(1,int *)
(2,5)
(3,data)
(4,globalReturnsTrueOrFalse()
(5,data[0])
(6,0)
(7,i)
(8,data[i] = 5)
(9,data = (int *)
(10,if(globalReturnsTrueOrFalse()
(11,)
(12,i)
(13,NULL)
(14,)
(15,RET)
(16,1)
(17,NULL)
(18,data[i])
(19,i < 100)
(20,sizeof(int)
(21,i)
(22,for(i = 0; i < 100; i++)
(23,data)
(24,-1)
(25,0)
(26,sizeof(int)
(27,data)
(28,)
(29,int)
(30,i = 0)
(31,100)
(32,i++)
(33,i)
(34,)
(35,if (data == NULL)
(36,exit(-1)
(37,)
(38,i)
(39,0)
(40,exit(-1)
(41,)
(42,int)
(43,malloc(100*sizeof(int)
(44,data = NULL)
(45,data = (int *)
(46,-1)
(47,i)
(48,100*sizeof(int)
(49,)
(50,data)
(51,100*sizeof(int)
(52,free(data)
(53,data)
(54,)
(55,malloc(100*sizeof(int)
(56,printIntLine(data[0])
(57,5)
(58,globalReturnsTrueOrFalse()
(59,i = 0)
(60,int *)
(61,for(i = 0; i < 100; i++)
(62,i)
(63,i < 100)
(64,NULL)
(65,)
(66,data)
(67,data[i])
(68,data == NULL)
(69,data)
(70,100)
(71,100)
(72,i++)
(73,i)
(74,i)
(75,100)
(76,data[i] = 5)
(77,(int *)
(78,data)
(79,i)
(80,if(globalReturnsTrueOrFalse()
(81,if (data == NULL)
(82,(int *)
(83,data)
(84,)
(85,data)
(86,1)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^