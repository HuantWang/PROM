<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mapie.classification &mdash; Prom v0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Prom
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../src/prom.html">prom module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../src/util.html">util module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../prom_mapie/mapie.conformity_scores.html">mapie.conformity_scores package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../prom_mapie/mapie.control_risk.html">mapie.control_risk package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../prom_mapie/mapie.estimator.html">mapie.estimator package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../prom_mapie/mapie.regression.html">mapie.regression package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../prom_mapie/mapie.tests.html">mapie.tests package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../prom_mapie/modules.html">thirdpackage</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Prom</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mapie.classification</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mapie.classification</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">BaseCrossValidator</span><span class="p">,</span> <span class="n">ShuffleSplit</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span><span class="p">,</span> <span class="n">label_binarize</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">_safe_indexing</span><span class="p">,</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.multiclass</span> <span class="kn">import</span> <span class="p">(</span><span class="n">check_classification_targets</span><span class="p">,</span>
                                      <span class="n">type_of_target</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_check_y</span><span class="p">,</span> <span class="n">_num_samples</span><span class="p">,</span> <span class="n">check_is_fitted</span><span class="p">,</span>
                                      <span class="n">indexable</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">._machine_precision</span> <span class="kn">import</span> <span class="n">EPSILON</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">.metrics</span> <span class="kn">import</span> <span class="n">classification_mean_width_score</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">check_alpha</span><span class="p">,</span> <span class="n">check_alpha_and_n_samples</span><span class="p">,</span> <span class="n">check_cv</span><span class="p">,</span>
                    <span class="n">check_estimator_classification</span><span class="p">,</span> <span class="n">check_n_features_in</span><span class="p">,</span>
                    <span class="n">check_n_jobs</span><span class="p">,</span> <span class="n">check_null_weight</span><span class="p">,</span> <span class="n">check_verbose</span><span class="p">,</span>
                    <span class="n">compute_quantiles</span><span class="p">,</span> <span class="n">fit_estimator</span><span class="p">,</span> <span class="n">fix_number_of_classes</span><span class="p">)</span>


<div class="viewcode-block" id="MapieClassifier"><a class="viewcode-back" href="../../prom_mapie/mapie.html#mapie.classification.MapieClassifier">[docs]</a><span class="k">class</span> <span class="nc">MapieClassifier</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prediction sets for classification.</span>

<span class="sd">    This class implements several conformal prediction strategies for</span>
<span class="sd">    estimating prediction sets for classification. Instead of giving a</span>
<span class="sd">    single predicted label, the idea is to give a set of predicted labels</span>
<span class="sd">    (or prediction sets) which come with mathematically guaranteed coverages.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    estimator: Optional[ClassifierMixin]</span>
<span class="sd">        Any classifier with scikit-learn API</span>
<span class="sd">        (i.e. with fit, predict, and predict_proba methods), by default None.</span>
<span class="sd">        If ``None``, estimator defaults to a ``LogisticRegression`` instance.</span>

<span class="sd">    method: Optional[str]</span>
<span class="sd">        Method to choose for prediction interval estimates.</span>
<span class="sd">        Choose among:</span>

<span class="sd">        - ``&quot;naive&quot;``, sum of the probabilities until the 1-alpha thresold.</span>

<span class="sd">        - ``&quot;lac&quot;`` (formerly called ``&quot;score&quot;``), Least Ambiguous set-valued</span>
<span class="sd">          Classifier. It is based on the the scores</span>
<span class="sd">          (i.e. 1 minus the softmax score of the true label)</span>
<span class="sd">          on the calibration set. See [1] for more details.</span>

<span class="sd">        - ``&quot;aps&quot;`` (formerly called &quot;cumulated_score&quot;), Adaptive Prediction</span>
<span class="sd">          Sets method. It is based on the sum of the softmax outputs of the</span>
<span class="sd">          labels until the true label is reached, on the calibration set.</span>
<span class="sd">          See [2] for more details.</span>

<span class="sd">        - ``&quot;raps&quot;``, Regularized Adaptive Prediction Sets method. It uses the</span>
<span class="sd">          same technique as ``&quot;aps&quot;`` method but with a penalty term</span>
<span class="sd">          to reduce the size of prediction sets. See [3] for more</span>
<span class="sd">          details. For now, this method only works with ``&quot;prefit&quot;`` and</span>
<span class="sd">          ``&quot;split&quot;`` strategies.</span>

<span class="sd">        - ``&quot;top_k&quot;``, based on the sorted index of the probability of the true</span>
<span class="sd">          label in the softmax outputs, on the calibration set. In case two</span>
<span class="sd">          probabilities are equal, both are taken, thus, the size of some</span>
<span class="sd">          prediction sets may be different from the others. See [3] for</span>
<span class="sd">          more details.</span>

<span class="sd">        By default ``&quot;lac&quot;``.</span>

<span class="sd">    cv: Optional[str]</span>
<span class="sd">        The cross-validation strategy for computing scores.</span>
<span class="sd">        It directly drives the distinction between jackknife and cv variants.</span>
<span class="sd">        Choose among:</span>

<span class="sd">        - ``None``, to use the default 5-fold cross-validation</span>
<span class="sd">        - integer, to specify the number of folds.</span>
<span class="sd">          If equal to -1, equivalent to</span>
<span class="sd">          ``sklearn.model_selection.LeaveOneOut()``.</span>
<span class="sd">        - CV splitter: any ``sklearn.model_selection.BaseCrossValidator``</span>
<span class="sd">          Main variants are:</span>
<span class="sd">          - ``sklearn.model_selection.LeaveOneOut`` (jackknife),</span>
<span class="sd">          - ``sklearn.model_selection.KFold`` (cross-validation)</span>
<span class="sd">        - ``&quot;split&quot;``, does not involve cross-validation but a division</span>
<span class="sd">          of the data into training and calibration subsets. The splitter</span>
<span class="sd">          used is the following: ``sklearn.model_selection.ShuffleSplit``.</span>
<span class="sd">        - ``&quot;prefit&quot;``, assumes that ``estimator`` has been fitted already.</span>
<span class="sd">          All data provided in the ``fit`` method is then used</span>
<span class="sd">          to calibrate the predictions through the score computation.</span>
<span class="sd">          At prediction time, quantiles of these scores are used to estimate</span>
<span class="sd">          prediction sets.</span>

<span class="sd">        By default ``None``.</span>

<span class="sd">    test_size: Optional[Union[int, float]]</span>
<span class="sd">        If float, should be between 0.0 and 1.0 and represent the proportion</span>
<span class="sd">        of the dataset to include in the test split. If int, represents the</span>
<span class="sd">        absolute number of test samples. If None, it will be set to 0.1.</span>

<span class="sd">        If cv is not ``&quot;split&quot;``, ``test_size`` is ignored.</span>

<span class="sd">        By default ``None``.</span>

<span class="sd">    n_jobs: Optional[int]</span>
<span class="sd">        Number of jobs for parallel processing using joblib</span>
<span class="sd">        via the &quot;locky&quot; backend.</span>
<span class="sd">        At this moment, parallel processing is disabled.</span>
<span class="sd">        If ``-1`` all CPUs are used.</span>
<span class="sd">        If ``1`` is given, no parallel computing code is used at all,</span>
<span class="sd">        which is useful for debugging.</span>
<span class="sd">        For n_jobs below ``-1``, ``(n_cpus + 1 + n_jobs)`` are used.</span>
<span class="sd">        None is a marker for `unset` that will be interpreted as ``n_jobs=1``</span>
<span class="sd">        (sequential execution).</span>

<span class="sd">        By default ``None``.</span>

<span class="sd">    random_state: Optional[Union[int, RandomState]]</span>
<span class="sd">        Pseudo random number generator state used for random uniform sampling</span>
<span class="sd">        for evaluation quantiles and prediction sets.</span>
<span class="sd">        Pass an int for reproducible output across multiple function calls.</span>

<span class="sd">        By default ``None``.</span>

<span class="sd">    verbose: int, optional</span>
<span class="sd">        The verbosity level, used with joblib for multiprocessing.</span>
<span class="sd">        At this moment, parallel processing is disabled.</span>
<span class="sd">        The frequency of the messages increases with the verbosity level.</span>
<span class="sd">        If it more than ``10``, all iterations are reported.</span>
<span class="sd">        Above ``50``, the output is sent to stdout.</span>

<span class="sd">        By default ``0``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    valid_methods: List[str]</span>
<span class="sd">        List of all valid methods.</span>

<span class="sd">    single_estimator_: sklearn.ClassifierMixin</span>
<span class="sd">        Estimator fitted on the whole training set.</span>

<span class="sd">    n_features_in_: int</span>
<span class="sd">        Number of features passed to the fit method.</span>

<span class="sd">    conformity_scores_: ArrayLike of shape (n_samples_train)</span>
<span class="sd">        The conformity scores used to calibrate the prediction sets.</span>

<span class="sd">    quantiles_: ArrayLike of shape (n_alpha)</span>
<span class="sd">        The quantiles estimated from ``conformity_scores_`` and alpha values.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Mauricio Sadinle, Jing Lei, and Larry Wasserman.</span>
<span class="sd">    &quot;Least Ambiguous Set-Valued Classifiers with Bounded Error Levels.&quot;,</span>
<span class="sd">    Journal of the American Statistical Association, 114, 2019.</span>

<span class="sd">    [2] Yaniv Romano, Matteo Sesia and Emmanuel J. Candès.</span>
<span class="sd">    &quot;Classification with Valid and Adaptive Coverage.&quot;</span>
<span class="sd">    NeurIPS 202 (spotlight) 2020.</span>

<span class="sd">    [3] Anastasios Nikolas Angelopoulos, Stephen Bates, Michael Jordan</span>
<span class="sd">    and Jitendra Malik.</span>
<span class="sd">    &quot;Uncertainty Sets for Image Classifiers using Conformal Prediction.&quot;</span>
<span class="sd">    International Conference on Learning Representations 2021.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.naive_bayes import GaussianNB</span>
<span class="sd">    &gt;&gt;&gt; from mapie.classification import MapieClassifier</span>
<span class="sd">    &gt;&gt;&gt; X_toy = np.arange(9).reshape(-1, 1)</span>
<span class="sd">    &gt;&gt;&gt; y_toy = np.stack([0, 0, 1, 0, 1, 2, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; clf = GaussianNB().fit(X_toy, y_toy)</span>
<span class="sd">    &gt;&gt;&gt; mapie = MapieClassifier(estimator=clf, cv=&quot;prefit&quot;).fit(X_toy, y_toy)</span>
<span class="sd">    &gt;&gt;&gt; _, y_pi_mapie = mapie.predict(X_toy, alpha=0.2)</span>
<span class="sd">    &gt;&gt;&gt; print(y_pi_mapie[:, :, 0])</span>
<span class="sd">    [[ True False False]</span>
<span class="sd">     [ True False False]</span>
<span class="sd">     [ True  True False]</span>
<span class="sd">     [ True  True False]</span>
<span class="sd">     [False  True False]</span>
<span class="sd">     [False  True  True]</span>
<span class="sd">     [False  True  True]</span>
<span class="sd">     [False False  True]</span>
<span class="sd">     [False False  True]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">raps_valid_cv_</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;prefit&quot;</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">]</span>
    <span class="n">valid_methods_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;naive&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;lac&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulated_score&quot;</span><span class="p">,</span> <span class="s2">&quot;aps&quot;</span><span class="p">,</span> <span class="s2">&quot;top_k&quot;</span><span class="p">,</span> <span class="s2">&quot;raps&quot;</span>
    <span class="p">]</span>
    <span class="n">fit_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;single_estimator_&quot;</span><span class="p">,</span>
        <span class="s2">&quot;estimators_&quot;</span><span class="p">,</span>
        <span class="s2">&quot;k_&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_features_in_&quot;</span><span class="p">,</span>
        <span class="s2">&quot;conformity_scores_&quot;</span><span class="p">,</span>
        <span class="s2">&quot;classes_&quot;</span><span class="p">,</span>
        <span class="s2">&quot;label_encoder_&quot;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">estimator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClassifierMixin</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lac&quot;</span><span class="p">,</span>
        <span class="n">cv</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">BaseCrossValidator</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="n">estimator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">=</span> <span class="n">cv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_size</span> <span class="o">=</span> <span class="n">test_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

    <span class="k">def</span> <span class="nf">_check_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform several checks on input parameters.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If parameters are not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_methods_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid method. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Allowed values are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">valid_methods_</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">check_n_jobs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">check_verbose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">check_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_depreciated</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_raps</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_check_depreciated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the chosen method is outdated.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Warning</span>
<span class="sd">            If method is ``&quot;score&quot;`` (not ``&quot;lac&quot;``) or</span>
<span class="sd">            if method is ``&quot;cumulated_score&quot;`` (not ``&quot;aps&quot;``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;score&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: Deprecated method. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;The method </span><span class="se">\&quot;</span><span class="s2">score</span><span class="se">\&quot;</span><span class="s2"> is outdated. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Prefer to use </span><span class="se">\&quot;</span><span class="s2">lac</span><span class="se">\&quot;</span><span class="s2"> instead to keep &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;the same behavior in the next release.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;cumulated_score&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: Deprecated method. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;The method </span><span class="se">\&quot;</span><span class="s2">cumulated_score</span><span class="se">\&quot;</span><span class="s2"> is outdated. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Prefer to use </span><span class="se">\&quot;</span><span class="s2">aps</span><span class="se">\&quot;</span><span class="s2"> instead to keep &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;the same behavior in the next release.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that if the type of target is binary,</span>
<span class="sd">        (then the method have to be ``&quot;lac&quot;``), or multi-class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y: NDArray of shape (n_samples,)</span>
<span class="sd">            Training labels.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If type of target is binary and method is not ``&quot;lac&quot;``</span>
<span class="sd">            or ``&quot;score&quot;`` or if type of target is not multi-class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_classification_targets</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_of_target</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;binary&quot;</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;lac&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid method for binary target. &quot;</span>
                <span class="s2">&quot;Your target is not of type multiclass and &quot;</span>
                <span class="s2">&quot;allowed values for binary type are &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;lac&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_raps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that if the method used is ``&quot;raps&quot;``, then</span>
<span class="sd">        the cross validation strategy is ``&quot;prefit&quot;``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``method`` is ``&quot;raps&quot;`` and ``cv`` is not ``&quot;prefit&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;raps&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">raps_valid_cv_</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">,</span> <span class="n">ShuffleSplit</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;RAPS method can only be used &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with cv in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">raps_valid_cv_</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_include_last_label</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include_last_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if ``include_last_label`` is a boolean or a string.</span>
<span class="sd">        Else raise error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_last_label: Optional[Union[bool, str]]</span>
<span class="sd">            Whether or not to include last label in</span>
<span class="sd">            prediction sets for the ``&quot;aps&quot;`` method. Choose among:</span>

<span class="sd">            - ``False``, does not include label whose cumulated score is just</span>
<span class="sd">            over the quantile.</span>
<span class="sd">            - ``True``, includes label whose cumulated score is just over the</span>
<span class="sd">            quantile, unless there is only one label in the prediction set.</span>
<span class="sd">            - ``&quot;randomized&quot;``, randomly includes label whose cumulated score</span>
<span class="sd">            is just over the quantile based on the comparison of a uniform</span>
<span class="sd">            number and the difference between the cumulated score of the last</span>
<span class="sd">            label and the quantile.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[Union[bool, str]]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            &quot;Invalid include_last_label argument. &quot;</span>
<span class="sd">            &quot;Should be a boolean or &#39;randomized&#39;.&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_last_label</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))</span> <span class="ow">and</span>
            <span class="p">(</span><span class="ow">not</span> <span class="n">include_last_label</span> <span class="o">==</span> <span class="s2">&quot;randomized&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid include_last_label argument. &quot;</span>
                <span class="s2">&quot;Should be a boolean or &#39;randomized&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">include_last_label</span>

    <span class="k">def</span> <span class="nf">_check_proba_normalized</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y_pred_proba</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if, for all the observations, the sum of</span>
<span class="sd">        the probabilities is equal to one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_pred_proba: ArrayLike of shape</span>
<span class="sd">            (n_samples, n_classes) or</span>
<span class="sd">            (n_samples, n_train_samples, n_classes)</span>
<span class="sd">            Softmax output of a model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike of shape (n_samples, n_classes)</span>
<span class="sd">            Softmax output of a model if the scores all sum</span>
<span class="sd">            to one.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">            ValueError</span>
<span class="sd">            If the sum of the scores is not equal to one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="n">err_msg</span><span class="o">=</span><span class="s2">&quot;The sum of the scores is not equal to one.&quot;</span><span class="p">,</span>
            <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
        <span class="p">)</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">y_pred_proba</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred_proba</span>

    <span class="k">def</span> <span class="nf">_get_last_index_included</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y_pred_proba_cumsum</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">include_last_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the index of the last included sorted probability</span>
<span class="sd">        depending if we included the first label over the quantile</span>
<span class="sd">        or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_pred_proba_cumsum: NDArray of shape (n_samples, n_classes)</span>
<span class="sd">            Cumsumed probabilities in the original order.</span>

<span class="sd">        threshold: NDArray of shape (n_alpha,) or shape (n_samples_train,)</span>
<span class="sd">            Threshold to compare with y_proba_last_cumsum, can be either:</span>

<span class="sd">            - the quantiles associated with alpha values when</span>
<span class="sd">              ``cv`` == &quot;prefit&quot;, ``cv`` == &quot;split&quot;</span>
<span class="sd">              or ``agg_scores`` is &quot;mean&quot;</span>
<span class="sd">            - the conformity score from training samples otherwise</span>
<span class="sd">              (i.e., when ``cv`` is a CV splitter and</span>
<span class="sd">              ``agg_scores`` is &quot;crossval&quot;)</span>

<span class="sd">        include_last_label: Union[bool, str]</span>
<span class="sd">            Whether or not include the last label. If &#39;randomized&#39;,</span>
<span class="sd">            the last label is included.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray of shape (n_samples, n_alpha)</span>
<span class="sd">            Index of the last included sorted probability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">include_last_label</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">include_last_label</span> <span class="o">==</span> <span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">y_pred_index_last</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span>
                        <span class="n">y_pred_proba_cumsum</span>
                        <span class="o">-</span> <span class="n">threshold</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                        <span class="o">-</span><span class="n">EPSILON</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">include_last_label</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">max_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                <span class="n">threshold</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_pred_proba_cumsum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">y_pred_index_last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span>
                    <span class="n">y_pred_proba_cumsum</span> <span class="o">-</span> <span class="n">max_threshold</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">EPSILON</span>
                <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid include_last_label argument. &quot;</span>
                <span class="s2">&quot;Should be a boolean or &#39;randomized&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred_index_last</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_add_random_tie_breaking</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prediction_sets</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">y_pred_index_last</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">y_pred_proba_cumsum</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">y_pred_proba_last</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">lambda_star</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">k_star</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly remove last label from prediction set based on the</span>
<span class="sd">        comparison between a random number and the difference between</span>
<span class="sd">        cumulated score of the last included label and the quantile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prediction_sets: NDArray of shape</span>
<span class="sd">            (n_samples, n_classes, n_threshold)</span>
<span class="sd">            Prediction set for each observation and each alpha.</span>

<span class="sd">        y_pred_index_last: NDArray of shape (n_samples, threshold)</span>
<span class="sd">            Index of the last included label.</span>

<span class="sd">        y_pred_proba_cumsum: NDArray of shape (n_samples, n_classes)</span>
<span class="sd">            Cumsumed probability of the model in the original order.</span>

<span class="sd">        y_pred_proba_last: NDArray of shape (n_samples, 1, threshold)</span>
<span class="sd">            Last included probability.</span>

<span class="sd">        threshold: NDArray of shape (n_alpha,) or shape (n_samples_train,)</span>
<span class="sd">            Threshold to compare with y_proba_last_cumsum, can be either:</span>

<span class="sd">            - the quantiles associated with alpha values when</span>
<span class="sd">              ``cv`` == &quot;prefit&quot;, ``cv`` == &quot;split&quot; or</span>
<span class="sd">              ``agg_scores`` is &quot;mean&quot;</span>
<span class="sd">            - the conformity score from training samples otherwise</span>
<span class="sd">              (i.e., when ``cv`` is a CV splitter and</span>
<span class="sd">              ``agg_scores`` is &quot;crossval&quot;)</span>

<span class="sd">        lambda_star: Union[NDArray, float, None] of shape (n_alpha):</span>
<span class="sd">            Optimal value of the regulizer lambda.</span>

<span class="sd">        k_star: Union[NDArray, None] of shape (n_alpha):</span>
<span class="sd">            Optimal value of the regulizer k.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray of shape (n_samples, n_classes, n_alpha)</span>
<span class="sd">            Updated version of prediction_sets with randomly removed</span>
<span class="sd">            labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get cumsumed probabilities up to last retained label</span>
        <span class="n">y_proba_last_cumsumed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
                <span class="n">y_pred_proba_cumsum</span><span class="p">,</span>
                <span class="n">y_pred_index_last</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cumulated_score&quot;</span><span class="p">,</span> <span class="s2">&quot;aps&quot;</span><span class="p">]:</span>
            <span class="c1"># compute V parameter from Romano+(2020)</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">y_proba_last_cumsumed</span> <span class="o">-</span> <span class="n">threshold</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span>
                <span class="n">y_pred_proba_last</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># compute V parameter from Angelopoulos+(2020)</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prediction_sets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">y_proba_last_cumsumed</span> <span class="o">-</span> <span class="n">threshold</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span>
                <span class="p">(</span>
                    <span class="n">y_pred_proba_last</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span>
                    <span class="n">lambda_star</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="n">k_star</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">lambda_star</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">&gt;</span> <span class="n">k_star</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># get random numbers for each observation and alpha value</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">us</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">prediction_sets</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># remove last label from comparison between uniform number and V</span>
        <span class="n">vs_less_than_us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">vs</span> <span class="o">-</span> <span class="n">us</span><span class="p">,</span> <span class="n">EPSILON</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put_along_axis</span><span class="p">(</span>
            <span class="n">prediction_sets</span><span class="p">,</span>
            <span class="n">y_pred_index_last</span><span class="p">,</span>
            <span class="n">vs_less_than_us</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction_sets</span>

    <span class="k">def</span> <span class="nf">_predict_oof_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">estimator</span><span class="p">:</span> <span class="n">ClassifierMixin</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict probabilities of a test set from a fitted estimator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        estimator: ClassifierMixin</span>
<span class="sd">            Fitted estimator.</span>

<span class="sd">        X: ArrayLike</span>
<span class="sd">            Test set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike</span>
<span class="sd">            Predicted probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># we enforce y_pred_proba to contain all labels included in y</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">estimator</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span><span class="p">:</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">fix_number_of_classes</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span><span class="p">,</span>
                <span class="n">estimator</span><span class="o">.</span><span class="n">classes_</span><span class="p">,</span>
                <span class="n">y_pred_proba</span>
            <span class="p">)</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_proba_normalized</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred_proba</span>

    <span class="k">def</span> <span class="nf">_fit_and_predict_oof_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">estimator</span><span class="p">:</span> <span class="n">ClassifierMixin</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">train_index</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">val_index</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">fit_params</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a single out-of-fold model on a given training set and</span>
<span class="sd">        perform predictions on a test set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        estimator: ClassifierMixin</span>
<span class="sd">            Estimator to train.</span>

<span class="sd">        X: ArrayLike of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y: ArrayLike of shape (n_samples,)</span>
<span class="sd">            Input labels.</span>

<span class="sd">        train_index: np.ndarray of shape (n_samples_train)</span>
<span class="sd">            Training data indices.</span>

<span class="sd">        val_index: np.ndarray of shape (n_samples_val)</span>
<span class="sd">            Validation data indices.</span>

<span class="sd">        k: int</span>
<span class="sd">            Split identification number.</span>

<span class="sd">        sample_weight: Optional[ArrayLike] of shape (n_samples,)</span>
<span class="sd">            Sample weights. If None, then samples are equally weighted.</span>
<span class="sd">            By default None.</span>

<span class="sd">        **fit_params : dict</span>
<span class="sd">            Additional fit parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[ClassifierMixin, NDArray, NDArray, ArrayLike]</span>

<span class="sd">        - [0]: ClassifierMixin, fitted estimator</span>
<span class="sd">        - [1]: NDArray of shape (n_samples_val,),</span>
<span class="sd">          Estimator predictions on the validation fold,</span>
<span class="sd">        - [2]: NDArray of shape (n_samples_val,)</span>
<span class="sd">          Identification number of the validation fold,</span>
<span class="sd">        - [3]: ArrayLike of shape (n_samples_val,)</span>
<span class="sd">          Validation data indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">train_index</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">train_index</span><span class="p">)</span>
        <span class="n">X_val</span> <span class="o">=</span> <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">val_index</span><span class="p">)</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">val_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">estimator</span> <span class="o">=</span> <span class="n">fit_estimator</span><span class="p">(</span>
                <span class="n">estimator</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_weight_train</span> <span class="o">=</span> <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">train_index</span><span class="p">)</span>
            <span class="n">estimator</span> <span class="o">=</span> <span class="n">fit_estimator</span><span class="p">(</span>
                <span class="n">estimator</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">sample_weight_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">_num_samples</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_oof_model</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">X_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">val_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">val_id</span><span class="p">,</span> <span class="n">val_index</span>

    <span class="k">def</span> <span class="nf">_get_true_label_cumsum_proba</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">y_pred_proba</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the cumsumed probability of the true label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y: NDArray of shape (n_samples, )</span>
<span class="sd">            Array with the labels.</span>
<span class="sd">        y_pred_proba: NDArray of shape (n_samples, n_classes)</span>
<span class="sd">            Predictions of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[NDArray, NDArray] of shapes</span>
<span class="sd">        (n_samples, 1) and (n_samples, ). The first element</span>
<span class="sd">        is the cumsum probability of the true label. The second</span>
<span class="sd">        is the sorted position of the true label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_true</span> <span class="o">=</span> <span class="n">label_binarize</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span>
        <span class="p">)</span>
        <span class="n">index_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">y_pred_proba_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
            <span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">index_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">y_true_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">index_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y_pred_proba_sorted_cumsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">y_pred_proba_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y_true_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">true_label_cumsum_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
            <span class="n">y_pred_proba_sorted_cumsum</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">true_label_cumsum_proba</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_regularize_conformity_score</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_star</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">lambda_</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">conf_score</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Regularize the conformity scores with the ``&quot;raps&quot;``</span>
<span class="sd">        method. See algo. 2 in [3].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_star: NDArray of shape (n_alphas, )</span>
<span class="sd">            Optimal value of k (called k_reg in the paper). There</span>
<span class="sd">            is one value per alpha.</span>

<span class="sd">        lambda_: Union[NDArray, float] of shape (n_alphas, )</span>
<span class="sd">            One value of lambda for each alpha.</span>

<span class="sd">        conf_score: NDArray of shape (n_samples, 1)</span>
<span class="sd">            Conformity scores.</span>

<span class="sd">        cutoff: NDArray of shape (n_samples, 1)</span>
<span class="sd">            Position of the true label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray of shape (n_samples, 1, n_alphas)</span>
<span class="sd">            Regularized conformity scores. The regularization</span>
<span class="sd">            depends on the value of alpha.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conf_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">conf_score</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_star</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">cutoff</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_star</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">conf_score</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
                <span class="n">lambda_</span> <span class="o">*</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">-</span> <span class="n">k_star</span><span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">),</span>
            <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">conf_score</span>

    <span class="k">def</span> <span class="nf">_get_true_label_position</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y_pred_proba</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sorted position of the true label in the</span>
<span class="sd">        prediction</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_pred_proba: NDArray of shape (n_samples, n_calsses)</span>
<span class="sd">            Model prediction.</span>

<span class="sd">        y: NDArray of shape (n_samples)</span>
<span class="sd">            Labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray of shape (n_samples, 1)</span>
<span class="sd">            Position of the true label in the prediction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">position</span>

    <span class="k">def</span> <span class="nf">_get_last_included_proba</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y_pred_proba</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">thresholds</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">include_last_label</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">lambda_</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">k_star</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that returns the smallest score</span>
<span class="sd">        among those which are included in the prediciton set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_pred_proba: NDArray of shape (n_samples, n_classes)</span>
<span class="sd">            Predictions of the model.</span>

<span class="sd">        thresholds: NDArray of shape (n_alphas, )</span>
<span class="sd">            Quantiles that have been computed from the conformity</span>
<span class="sd">            scores.</span>

<span class="sd">        include_last_label: Union[bool, str, None]</span>
<span class="sd">            Whether to include or not the label whose score</span>
<span class="sd">            exceeds the threshold.</span>

<span class="sd">        lambda_: Union[NDArray, float, None] of shape (n_alphas)</span>
<span class="sd">            Values of lambda for the regularization.</span>

<span class="sd">        k_star: Union[NDArray, Any]</span>
<span class="sd">            Values of k for the regularization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[ArrayLike, ArrayLike, ArrayLike]</span>
<span class="sd">            Arrays of shape (n_samples, n_classes, n_alphas),</span>
<span class="sd">            (n_samples, 1, n_alphas) and (n_samples, 1, n_alphas).</span>
<span class="sd">            They are respectively the cumsumed scores in the original</span>
<span class="sd">            order which can be different according to the value of alpha</span>
<span class="sd">            with the RAPS method, the index of the last included score</span>
<span class="sd">            and the value of the last included score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="c1"># sort probabilities by decreasing order</span>
        <span class="n">y_pred_proba_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
            <span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">index_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="c1"># get sorted cumulated score</span>
        <span class="n">y_pred_proba_sorted_cumsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="n">y_pred_proba_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;raps&quot;</span><span class="p">:</span>
            <span class="n">y_pred_proba_sorted_cumsum</span> <span class="o">+=</span> <span class="n">lambda_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y_pred_proba_sorted_cumsum</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">k_star</span>
            <span class="p">)</span>
        <span class="c1"># get cumulated score at their original position</span>
        <span class="n">y_pred_proba_cumsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
            <span class="n">y_pred_proba_sorted_cumsum</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">index_sorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="c1"># get index of the last included label</span>
        <span class="n">y_pred_index_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_index_included</span><span class="p">(</span>
            <span class="n">y_pred_proba_cumsum</span><span class="p">,</span>
            <span class="n">thresholds</span><span class="p">,</span>
            <span class="n">include_last_label</span>
        <span class="p">)</span>
        <span class="c1"># get the probability of the last included label</span>
        <span class="n">y_pred_proba_last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
            <span class="n">y_pred_proba</span><span class="p">,</span>
            <span class="n">y_pred_index_last</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">zeros_scores_proba_last</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_pred_proba_last</span> <span class="o">&lt;=</span> <span class="n">EPSILON</span><span class="p">)</span>

        <span class="c1"># If the last included proba is zero, change it to the</span>
        <span class="c1"># smallest non-zero value to avoid inluding them in the</span>
        <span class="c1"># prediction sets.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zeros_scores_proba_last</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y_pred_proba_last</span><span class="p">[</span><span class="n">zeros_scores_proba_last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span>
                        <span class="n">y_pred_proba</span><span class="p">,</span>
                        <span class="n">EPSILON</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)[</span><span class="n">zeros_scores_proba_last</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_pred_proba_cumsum</span><span class="p">,</span> <span class="n">y_pred_index_last</span><span class="p">,</span> <span class="n">y_pred_proba_last</span>

    <span class="k">def</span> <span class="nf">_update_size_and_lambda</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">best_sizes</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">alpha_np</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">y_ps</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">lambda_</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">lambda_star</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Update the values of the optimal lambda if the</span>
<span class="sd">        average size of the prediction sets decreases with</span>
<span class="sd">        this new value of lambda.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        best_sizes: NDArray of shape (n_alphas, )</span>
<span class="sd">            Smallest average prediciton set size before testing</span>
<span class="sd">            for the new value of lambda_</span>

<span class="sd">        alpha_np: NDArray of shape (n_alphas)</span>
<span class="sd">            Level of confidences.</span>

<span class="sd">        y_ps: NDArray of shape (n_samples, n_classes, n_alphas)</span>
<span class="sd">            Prediction sets computed with the RAPS method and the</span>
<span class="sd">            new value of lambda_</span>

<span class="sd">        lambda_: NDArray of shape (n_alphas, )</span>
<span class="sd">            New value of lambda_star to test</span>

<span class="sd">        lambda_star: NDArray of shape (n_alphas, )</span>
<span class="sd">            Actual optimal lambda values for each alpha.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[NDArray, NDArray]</span>
<span class="sd">            Arrays of shape (n_alphas, ) and (n_alpha, ) which</span>
<span class="sd">            respectively represent the updated values of lambda_star</span>
<span class="sd">            and the new best sizes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">classification_mean_width_score</span><span class="p">(</span>
                <span class="n">y_ps</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">sizes_improve</span> <span class="o">=</span> <span class="p">(</span><span class="n">sizes</span> <span class="o">&lt;</span> <span class="n">best_sizes</span> <span class="o">-</span> <span class="n">EPSILON</span><span class="p">)</span>
        <span class="n">lambda_star</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">sizes_improve</span> <span class="o">*</span> <span class="n">lambda_</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sizes_improve</span><span class="p">)</span> <span class="o">*</span> <span class="n">lambda_star</span>
        <span class="p">)</span>
        <span class="n">best_sizes</span> <span class="o">=</span> <span class="n">sizes_improve</span> <span class="o">*</span> <span class="n">sizes</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sizes_improve</span><span class="p">)</span> <span class="o">*</span> <span class="n">best_sizes</span>

        <span class="k">return</span> <span class="n">lambda_star</span><span class="p">,</span> <span class="n">best_sizes</span>

    <span class="k">def</span> <span class="nf">_find_lambda_star</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y_pred_proba_raps</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">alpha_np</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">include_last_label</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">k_star</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Find the optimal value of lambda for each alpha.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_pred_proba_raps: NDArray of shape (n_samples, n_labels, n_alphas)</span>
<span class="sd">            Predictions of the model repeated on the last axis as many times</span>
<span class="sd">            as the number of alphas</span>

<span class="sd">        alpha_np: NDArray of shape (n_alphas, )</span>
<span class="sd">            Levels of confidences.</span>

<span class="sd">        include_last_label: bool</span>
<span class="sd">            Whether to include or not last label in</span>
<span class="sd">            the prediction sets</span>

<span class="sd">        k_star: NDArray of shape (n_alphas, )</span>
<span class="sd">            Values of k for the regularization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike of shape (n_alphas, )</span>
<span class="sd">            Optimal values of lambda.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">))</span>
        <span class="n">best_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lambda_</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">.001</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]:</span>  <span class="c1"># values given in paper[3]</span>
            <span class="n">true_label_cumsum_proba</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_true_label_cumsum_proba</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y_raps_no_enc</span><span class="p">,</span>
                    <span class="n">y_pred_proba_raps</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">true_label_cumsum_proba_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regularize_conformity_score</span><span class="p">(</span>
                <span class="n">k_star</span><span class="p">,</span>
                <span class="n">lambda_</span><span class="p">,</span>
                <span class="n">true_label_cumsum_proba</span><span class="p">,</span>
                <span class="n">cutoff</span>
            <span class="p">)</span>

            <span class="n">quantiles_</span> <span class="o">=</span> <span class="n">compute_quantiles</span><span class="p">(</span>
                <span class="n">true_label_cumsum_proba_reg</span><span class="p">,</span>
                <span class="n">alpha_np</span>
            <span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">y_pred_proba_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_included_proba</span><span class="p">(</span>
                <span class="n">y_pred_proba_raps</span><span class="p">,</span>
                <span class="n">quantiles_</span><span class="p">,</span>
                <span class="n">include_last_label</span><span class="p">,</span>
                <span class="n">lambda_</span><span class="p">,</span>
                <span class="n">k_star</span>
            <span class="p">)</span>

            <span class="n">y_ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span>
                    <span class="n">y_pred_proba_raps</span> <span class="o">-</span> <span class="n">y_pred_proba_last</span><span class="p">,</span> <span class="o">-</span><span class="n">EPSILON</span>
            <span class="p">)</span>
            <span class="n">lambda_star</span><span class="p">,</span> <span class="n">best_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_size_and_lambda</span><span class="p">(</span>
                <span class="n">best_sizes</span><span class="p">,</span> <span class="n">alpha_np</span><span class="p">,</span> <span class="n">y_ps</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">lambda_star</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_star</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lambda_star</span> <span class="o">=</span> <span class="n">lambda_star</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lambda_star</span>

    <span class="k">def</span> <span class="nf">_get_classes_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">estimator</span><span class="p">:</span> <span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of classes and the classes values</span>
<span class="sd">        according to either the pre-trained model or to the</span>
<span class="sd">        values in y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        estimator: ClassifierMixin</span>
<span class="sd">            Estimator pre-fitted or not.</span>

<span class="sd">        y: NDArray</span>
<span class="sd">            Values to predict.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[int, NDArray]</span>
<span class="sd">            The number of unique classes and their unique</span>
<span class="sd">            values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `cv=&quot;prefit&quot;` and that classes in `y` are not included into</span>
<span class="sd">            `estimator.classes_`.</span>

<span class="sd">        Warning</span>
<span class="sd">            If number of calibration labels is lower than number of labels</span>
<span class="sd">            for training (in prefit setting)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_unique_y_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">:</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">classes_</span>
            <span class="n">n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">classes</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">classes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Values in y do not matched values in estimator.classes_.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; Check that you are not adding any new label&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">n_classes</span> <span class="o">&gt;</span> <span class="n">n_unique_y_labels</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;WARNING: your calibration dataset has less labels&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; than your training dataset (training&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; has </span><span class="si">{</span><span class="n">n_classes</span><span class="si">}</span><span class="s2"> unique labels while&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; calibration have </span><span class="si">{</span><span class="n">n_unique_y_labels</span><span class="si">}</span><span class="s2"> unique labels&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_classes</span> <span class="o">=</span> <span class="n">n_unique_y_labels</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">n_classes</span><span class="p">,</span> <span class="n">classes</span>

<div class="viewcode-block" id="MapieClassifier.fit"><a class="viewcode-back" href="../../prom_mapie/mapie.html#mapie.classification.MapieClassifier.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">X</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">size_raps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">.2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MapieClassifier</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the base estimator or use the fitted base estimator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ArrayLike of shape (n_samples, n_features)</span>
<span class="sd">            Training data.</span>

<span class="sd">        y : NDArray of shape (n_samples,)</span>
<span class="sd">            Training labels.</span>

<span class="sd">        sample_weight : Optional[ArrayLike] of shape (n_samples,)</span>
<span class="sd">            Sample weights for fitting the out-of-fold models.</span>
<span class="sd">            If None, then samples are equally weighted.</span>
<span class="sd">            If some weights are null,</span>
<span class="sd">            their corresponding observations are removed</span>
<span class="sd">            before the fitting process and hence have no prediction sets.</span>

<span class="sd">            By default None.</span>

<span class="sd">        size_raps: Optional[float]</span>
<span class="sd">            Percentage of the data to be used for choosing lambda_star and</span>
<span class="sd">            k_star for the RAPS method.</span>

<span class="sd">            By default .2.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MapieClassifier</span>
<span class="sd">            The model itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_parameters</span><span class="p">()</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">check_cv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">indexable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_check_y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">],</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="n">sample_weight</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">check_null_weight</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">estimator</span> <span class="o">=</span> <span class="n">check_estimator_classification</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">cv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_in_</span> <span class="o">=</span> <span class="n">check_n_features_in</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">cv</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>

        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">_num_samples</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_classes_info</span><span class="p">(</span>
                <span class="n">estimator</span><span class="p">,</span> <span class="n">y</span>
            <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># This is thread coarsening</span>
            <span class="c1"># self.classes_=[0,1,2,3,4,5]</span>
            <span class="c1"># self.n_classes_= 6</span>
            <span class="c1"># This is loop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">35</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">=</span> <span class="mi">35</span>
        <span class="n">enc</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span>
        <span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span>
        <span class="n">y_enc</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label_encoder_</span> <span class="o">=</span> <span class="n">enc</span>
        <span class="n">check_classification_targets</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_type</span> <span class="o">=</span> <span class="s2">&quot;multiclass&quot;</span>

        <span class="c1"># Initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ClassifierMixin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span> <span class="o">=</span> <span class="n">_num_samples</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_type</span> <span class="o">==</span> <span class="s2">&quot;multiclass&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;raps&quot;</span><span class="p">:</span>
                <span class="n">raps_split</span> <span class="o">=</span> <span class="n">ShuffleSplit</span><span class="p">(</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">size_raps</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
                <span class="p">)</span>
                <span class="n">train_raps_index</span><span class="p">,</span> <span class="n">val_raps_index</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">raps_split</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_raps</span><span class="p">,</span> <span class="n">y_enc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_raps</span> <span class="o">=</span> \
                    <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">train_raps_index</span><span class="p">),</span> \
                    <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">val_raps_index</span><span class="p">),</span> \
                    <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">y_enc</span><span class="p">,</span> <span class="n">train_raps_index</span><span class="p">),</span> \
                    <span class="n">_safe_indexing</span><span class="p">(</span><span class="n">y_enc</span><span class="p">,</span> <span class="n">val_raps_index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_raps_no_enc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_encoder_</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y_raps</span>
                <span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_encoder_</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_enc</span><span class="p">)</span>
                <span class="n">y_enc</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">y_enc</span><span class="p">)</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="n">_num_samples</span><span class="p">(</span><span class="n">y_enc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">sample_weight</span><span class="p">[</span><span class="n">train_raps_index</span><span class="p">]</span>
                    <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>

            <span class="c1"># Work</span>
            <span class="k">if</span> <span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span> <span class="o">=</span> <span class="n">estimator</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_proba_normalized</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">BaseCrossValidator</span><span class="p">,</span> <span class="n">cv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span> <span class="o">=</span> <span class="n">fit_estimator</span><span class="p">(</span>
                    <span class="n">clone</span><span class="p">(</span><span class="n">estimator</span><span class="p">),</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span>
                <span class="p">)</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                <span class="p">)</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)(</span>
                    <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_and_predict_oof_model</span><span class="p">)(</span>
                        <span class="n">clone</span><span class="p">(</span><span class="n">estimator</span><span class="p">),</span>
                        <span class="n">X</span><span class="p">,</span>
                        <span class="n">y</span><span class="p">,</span>
                        <span class="n">train_index</span><span class="p">,</span>
                        <span class="n">val_index</span><span class="p">,</span>
                        <span class="n">k</span><span class="p">,</span>
                        <span class="n">sample_weight</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">train_index</span><span class="p">,</span> <span class="n">val_index</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">,</span>
                    <span class="n">predictions_list</span><span class="p">,</span>
                    <span class="n">val_ids_list</span><span class="p">,</span>
                    <span class="n">val_indices_list</span>
                <span class="p">)</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">outputs</span><span class="p">))</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">NDArray</span><span class="p">],</span>
                         <span class="n">predictions_list</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">val_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">NDArray</span><span class="p">],</span> <span class="n">val_ids_list</span><span class="p">))</span>
                <span class="n">val_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">NDArray</span><span class="p">],</span> <span class="n">val_indices_list</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">val_ids</span>
                <span class="n">y_pred_proba</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">predictions</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="n">ShuffleSplit</span><span class="p">):</span>
                    <span class="c1"># Should delete values indices that</span>
                    <span class="c1"># are not used during calibration</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span>
                    <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">y_pred_proba</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span>
                    <span class="n">y_enc</span> <span class="o">=</span> <span class="n">y_enc</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="n">val_indices</span><span class="p">]</span>

            <span class="c1"># RAPS: compute y_pred and position on the RAPS validation dataset</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;raps&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_pred_proba_raps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_raps</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">position_raps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_true_label_position</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y_pred_proba_raps</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y_raps</span>
                <span class="p">)</span>

            <span class="c1"># Conformity scores</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;naive&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;score&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
                    <span class="mi">1</span> <span class="o">-</span> <span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">y_enc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cumulated_score&quot;</span><span class="p">,</span> <span class="s2">&quot;raps&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_true_label_cumsum_proba</span><span class="p">(</span>
                        <span class="n">y</span><span class="p">,</span>
                        <span class="n">y_pred_proba</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">y_proba_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">y_enc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span> <span class="o">-=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">y_proba_true</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;top_k&quot;</span><span class="p">:</span>
                <span class="c1"># Here we reorder the labels by decreasing probability</span>
                <span class="c1"># and get the position of each label from decreasing</span>
                <span class="c1"># probability</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_true_label_position</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span><span class="p">,</span>
                    <span class="n">y_enc</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid method. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Allowed values are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">valid_methods_</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="n">ShuffleSplit</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: your target is not of type multiclass.&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; Still fitting the model but not conformal prediction&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; algorithm will be run.&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span> <span class="o">=</span> <span class="n">estimator</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span> <span class="o">=</span> <span class="n">fit_estimator</span><span class="p">(</span>
                    <span class="n">clone</span><span class="p">(</span><span class="n">estimator</span><span class="p">),</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">y_enc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MapieClassifier.predict"><a class="viewcode-back" href="../../prom_mapie/mapie.html#mapie.classification.MapieClassifier.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_last_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">agg_scores</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prediction prediction sets on new samples based on target confidence</span>
<span class="sd">        interval.</span>
<span class="sd">        Prediction sets for a given ``alpha`` are deduced from:</span>

<span class="sd">        - quantiles of softmax scores (``&quot;lac&quot;`` method)</span>
<span class="sd">        - quantiles of cumulated scores (``&quot;aps&quot;`` method)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: ArrayLike of shape (n_samples, n_features)</span>
<span class="sd">            Test data.</span>

<span class="sd">        alpha: Optional[Union[float, Iterable[float]]]</span>
<span class="sd">            Can be a float, a list of floats, or a ``ArrayLike`` of floats.</span>
<span class="sd">            Between 0 and 1, represent the uncertainty of the confidence</span>
<span class="sd">            interval.</span>
<span class="sd">            Lower ``alpha`` produce larger (more conservative) prediction</span>
<span class="sd">            sets.</span>
<span class="sd">            ``alpha`` is the complement of the target coverage level.</span>

<span class="sd">            By default ``None``.</span>

<span class="sd">        include_last_label: Optional[Union[bool, str]]</span>
<span class="sd">            Whether or not to include last label in</span>
<span class="sd">            prediction sets for the &quot;aps&quot; method. Choose among:</span>

<span class="sd">            - False, does not include label whose cumulated score is just over</span>
<span class="sd">              the quantile.</span>
<span class="sd">            - True, includes label whose cumulated score is just over the</span>
<span class="sd">              quantile, unless there is only one label in the prediction set.</span>
<span class="sd">            - &quot;randomized&quot;, randomly includes label whose cumulated score is</span>
<span class="sd">              just over the quantile based on the comparison of a uniform</span>
<span class="sd">              number and the difference between the cumulated score of</span>
<span class="sd">              the last label and the quantile.</span>

<span class="sd">            When set to ``True`` or ``False``, it may result in a coverage</span>
<span class="sd">            higher than ``1 - alpha`` (because contrary to the &quot;randomized&quot;</span>
<span class="sd">            setting, none of this methods create empty prediction sets). See</span>
<span class="sd">            [2] and [3] for more details.</span>

<span class="sd">            By default ``True``.</span>

<span class="sd">        agg_scores: Optional[str]</span>

<span class="sd">            How to aggregate the scores output by the estimators on test data</span>
<span class="sd">            if a cross-validation strategy is used. Choose among:</span>

<span class="sd">            - &quot;mean&quot;, take the mean of scores.</span>
<span class="sd">            - &quot;crossval&quot;, compare the scores between all training data and each</span>
<span class="sd">              test point for each label to estimate if the label must be</span>
<span class="sd">              included in the prediction set. Follows algorithm 2 of</span>
<span class="sd">              Romano+2020.</span>

<span class="sd">            By default &quot;mean&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[NDArray, Tuple[NDArray, NDArray]]</span>

<span class="sd">        - NDArray of shape (n_samples,) if alpha is None.</span>

<span class="sd">        - Tuple[NDArray, NDArray] of shapes</span>
<span class="sd">        (n_samples,) and (n_samples, n_classes, n_alpha) if alpha is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;top_k&quot;</span><span class="p">:</span>
            <span class="n">agg_scores</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
        <span class="c1"># Checks</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">check_cv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="p">)</span>
        <span class="n">include_last_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_include_last_label</span><span class="p">(</span><span class="n">include_last_label</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">],</span> <span class="n">check_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_attributes</span><span class="p">)</span>
        <span class="n">lambda_star</span><span class="p">,</span> <span class="n">k_star</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># Estimate prediction sets</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y_pred</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span><span class="p">)</span>

        <span class="c1"># Estimate of probabilities from estimator(s)</span>
        <span class="c1"># In all cases: len(y_pred_proba.shape) == 3</span>
        <span class="c1"># with  (n_test, n_classes, n_alpha or n_train_samples)</span>
        <span class="n">alpha_np</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">check_alpha_and_n_samples</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">:</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_estimator_</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">y_pred_proba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_pred_proba_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="n">Parallel</span><span class="p">(</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
                <span class="p">)(</span>
                    <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predict_oof_model</span><span class="p">)(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">agg_scores</span> <span class="o">==</span> <span class="s2">&quot;crossval&quot;</span><span class="p">:</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">y_pred_proba_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">agg_scores</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_pred_proba_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid &#39;agg_scores&#39; argument.&quot;</span><span class="p">)</span>
        <span class="c1"># Check that sum of probas is equal to 1</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_proba_normalized</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Choice of the quantile</span>
        <span class="n">check_alpha_and_n_samples</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;naive&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_np</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">agg_scores</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;raps&quot;</span><span class="p">:</span>
                    <span class="n">check_alpha_and_n_samples</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_raps</span><span class="p">))</span>
                    <span class="n">k_star</span> <span class="o">=</span> <span class="n">compute_quantiles</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">position_raps</span><span class="p">,</span>
                        <span class="n">alpha_np</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">y_pred_proba_raps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">y_pred_proba_raps</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">alpha_np</span><span class="p">),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
                    <span class="p">)</span>
                    <span class="n">lambda_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_lambda_star</span><span class="p">(</span>
                        <span class="n">y_pred_proba_raps</span><span class="p">,</span>
                        <span class="n">alpha_np</span><span class="p">,</span>
                        <span class="n">include_last_label</span><span class="p">,</span>
                        <span class="n">k_star</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_regularized</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_regularize_conformity_score</span><span class="p">(</span>
                                    <span class="n">k_star</span><span class="p">,</span>
                                    <span class="n">lambda_star</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span> <span class="o">=</span> <span class="n">compute_quantiles</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_regularized</span><span class="p">,</span>
                        <span class="n">alpha_np</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span> <span class="o">=</span> <span class="n">compute_quantiles</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span><span class="p">,</span>
                        <span class="n">alpha_np</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_np</span><span class="p">)</span>

        <span class="c1"># Build prediction sets</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;lac&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">agg_scores</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">):</span>
                <span class="n">prediction_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span><span class="p">),</span> <span class="o">-</span><span class="n">EPSILON</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_pred_included</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_pred_proba</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">EPSILON</span>
                <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">prediction_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span>
                            <span class="n">y_pred_included</span> <span class="o">-</span> <span class="n">_alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">EPSILON</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">_alpha</span> <span class="ow">in</span> <span class="n">alpha_np</span>
                    <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;naive&quot;</span><span class="p">,</span> <span class="s2">&quot;cumulated_score&quot;</span><span class="p">,</span> <span class="s2">&quot;aps&quot;</span><span class="p">,</span> <span class="s2">&quot;raps&quot;</span><span class="p">]:</span>
            <span class="c1"># specify which thresholds will be used</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">agg_scores</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]):</span>
                <span class="n">thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformity_scores_</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="c1"># sort labels by decreasing probability</span>
            <span class="n">y_pred_proba_cumsum</span><span class="p">,</span> <span class="n">y_pred_index_last</span><span class="p">,</span> <span class="n">y_pred_proba_last</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_included_proba</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span><span class="p">,</span>
                    <span class="n">thresholds</span><span class="p">,</span>
                    <span class="n">include_last_label</span><span class="p">,</span>
                    <span class="n">lambda_star</span><span class="p">,</span>
                    <span class="n">k_star</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># get the prediction set by taking all probabilities</span>
            <span class="c1"># above the last one</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">agg_scores</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]):</span>
                <span class="n">y_pred_included</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span> <span class="o">-</span> <span class="n">y_pred_proba_last</span><span class="p">,</span> <span class="o">-</span><span class="n">EPSILON</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_pred_included</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span>
                    <span class="n">y_pred_proba</span> <span class="o">-</span> <span class="n">y_pred_proba_last</span><span class="p">,</span> <span class="n">EPSILON</span>
                <span class="p">)</span>
            <span class="c1"># remove last label randomly</span>
            <span class="k">if</span> <span class="n">include_last_label</span> <span class="o">==</span> <span class="s2">&quot;randomized&quot;</span><span class="p">:</span>
                <span class="n">y_pred_included</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_random_tie_breaking</span><span class="p">(</span>
                    <span class="n">y_pred_included</span><span class="p">,</span>
                    <span class="n">y_pred_index_last</span><span class="p">,</span>
                    <span class="n">y_pred_proba_cumsum</span><span class="p">,</span>
                    <span class="n">y_pred_proba_last</span><span class="p">,</span>
                    <span class="n">thresholds</span><span class="p">,</span>
                    <span class="n">lambda_star</span><span class="p">,</span>
                    <span class="n">k_star</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="s2">&quot;prefit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">agg_scores</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]):</span>
                <span class="n">prediction_sets</span> <span class="o">=</span> <span class="n">y_pred_included</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># compute the number of times the inequality is verified</span>
                <span class="n">prediction_sets_summed</span> <span class="o">=</span> <span class="n">y_pred_included</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">prediction_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span>
                    <span class="n">prediction_sets_summed</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">EPSILON</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;top_k&quot;</span><span class="p">:</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">y_pred_proba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">index_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">y_pred_index_last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">index_sorted</span><span class="p">[:,</span> <span class="n">quantile</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span>
                <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">y_pred_proba_last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span>
                        <span class="n">y_pred_proba</span><span class="p">,</span>
                        <span class="n">y_pred_index_last</span><span class="p">[:,</span> <span class="n">iq</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quantiles_</span><span class="p">)</span>
                <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">prediction_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span>
                <span class="n">y_pred_proba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">y_pred_proba_last</span><span class="p">,</span>
                <span class="o">-</span><span class="n">EPSILON</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid method. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Allowed values are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">valid_methods_</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">prediction_sets</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, _.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>